<ng-container>
    <section>
        <h1>Templates</h1>
        <mat-accordion>
          <ng-container *ngTemplateOutlet="introductionTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="textInterpolationTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="templateStatementsTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="pipesTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="propertyBindingTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="acsBindingsTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="eventBindingTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="twoWayBindingTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="templateReferenceVariableTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="svgTemplatesTemplate"></ng-container>
        </mat-accordion>
    </section>
</ng-container>

<ng-template #introductionTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Overview
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Prerequisites
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <ul>
                                    <li>Angular concepts</li>
                                    <li>JavaScript</li>
                                    <li>HTML</li>
                                    <li>CSS</li>
                                </ul>

                                <p>Each Angular template in your application is a section of HTML to include as a part of the page that the browser displays. An Angular HTML template renders a view, or user interface, in the browser, just like regular HTML, but with a lot more functionality.</p>
                                <p>When you generate an Angular application with the Angular CLI, the app.component.html file is the default template containing placeholder HTML.</p>
                                <p>The template syntax guides show you how to control the UX/UI by coordinating data between the class and the template.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Empower your HTML
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Extend the HTML vocabulary of your applications With special Angular syntax in your templates. For example, Angular helps you get and set DOM (Document Object Model) values dynamically with features such as built-in template functions, variables, event listening, and data binding.</p>
                                <p>Almost all HTML syntax is valid template syntax. However, because an Angular template is part of an overall webpage, and not the entire page, you don't need to include elements such as < html>, < body>, or < base>, and can focus exclusively on the part of the page you are developing.</p>

                                <p class="notes">To eliminate the risk of script injection attacks, Angular does not support the  script > element in templates. Angular ignores the  script> tag and outputs a warning to the browser console. For more information, see the Security page.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                More on template syntax
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>You might also be interested in the following:</p>

                                <ul>
                                    <li>Interpolation—learn how to use interpolation and expressions in HTML.</li>
                                    <li>Template statements—respond to events in your templates.</li>
                                    <li>Binding syntax—use binding to coordinate values in your application.</li>
                                    <li>Property binding—set properties of target elements or directive @Input() decorators.</li>
                                    <li>Attribute, class, and style bindings—set the value of attributes, classes, and styles.</li>
                                    <li>Event binding—listen for events and your HTML.</li>
                                    <li>Two-way binding—share data between a class and its template.</li>
                                    <li>Built-in directives—listen to and modify the behavior and layout of HTML.</li>
                                    <li>Template reference variables—use special variables to reference a DOM element within a template.</li>
                                    <li>Inputs and Outputs—share data between the parent context and child directives or components</li>
                                    <li>Template expression operators—learn about the pipe operator, |, and protect against null or undefined values in your HTML.</li>
                                    <li>SVG in templates—dynamically generate interactive graphics.</li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #textInterpolationTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Text interpolation
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Text interpolation lets you incorporate dynamic string values into your HTML templates. Use interpolation to dynamically change what appears in an application view, such as displaying a custom greeting that includes the user's name.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Displaying values with interpolation
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>Interpolation refers to embedding expressions into marked up text. By default, interpolation uses the double curly braces {{ "{{ and }}" }} as delimiters.</p>
                                <p>To illustrate how interpolation works, consider an Angular component that contains a currentCustomer variable:</p>
                                <code-example code="
                                    currentCustomer = 'Maria';
                                "></code-example>

                                <p>Use interpolation to display the value of this variable in the corresponding component template:</p>
                                <code-example code="
                                 < h3>Current customer: { currentCustomer }</h3>
                                "></code-example>
                                <p>Angular replaces currentCustomer with the string value of the corresponding component property. In this case, the value is Maria.</p>

                                <p>In the following example, Angular evaluates the title and itemImageUrl properties to display some title text and an image.</p>
                                <code-example code="
                                    < p>{title}</p>
                                    < div><img src='{itemImageUrl}'></div>
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Template expressions
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>A template expression produces a value and appears within double curly braces, {{ "{{ }}" }}. Angular resolves the expression and assigns it to a property of a binding target. The target could be an HTML element, a component, or a directive.</p>
                            
                                <ng-container #contentt2_1>
                                    <mat-accordion>
                                        <mat-expansion-panel>
                                            <mat-expansion-panel-header>
                                                <mat-panel-title>
                                                    Resolving expressions with interpolation
                                                </mat-panel-title>
                                            </mat-expansion-panel-header>
                            
                                            <ng-container #content2Conten_1>
                                                <ng-container #description_2_1>
                                                    <p>More generally, the text between the braces is a template expression that Angular first evaluates and then converts to a string. The following interpolation illustrates the point by adding two numbers:</p>
                                                
                                                    <code-example code="
                                                        < !-- 'The sum of 1 + 1 is 2' -->
                                                        < p>The sum of 1 + 1 is {1 + 1}.</p>
                                                    "></code-example>

                                                    <p>Expressions can also invoke methods of the host component such as getVal() in the following example:</p>
                                                    <code-example code="
                                                        < !-- 'The sum of 1 + 1 is not 4' -->
                                                        < p>The sum of 1 + 1 is not {1 + 1 + getVal()}.</p>
                                                    "></code-example>

                                                    <p>With interpolation, Angular performs the following tasks:</p>
                                                    <ol>
                                                        <li>Evaluates all expressions in double curly braces.</li>
                                                        <li>Converts the expression results to strings.</li>
                                                        <li>Links the results to any adjacent literal strings.</li>
                                                        <li>Assigns the composite to an element or directive property.</li>
                                                    </ol>

                                                    <p class="notes">Configure the interpolation delimiter with the interpolation option in the @Component() metadata.</p>
                                                </ng-container>
                                            </ng-container>
                                        </mat-expansion-panel>
                                    </mat-accordion>
                                </ng-container>

                                <ng-container #content2_2>
                                    <mat-accordion>
                                        <mat-expansion-panel>
                                            <mat-expansion-panel-header>
                                                <mat-panel-title>
                                                    Syntax
                                                </mat-panel-title>
                                            </mat-expansion-panel-header>
                            
                                            <ng-container #content2Content_2>
                                                <ng-container #description_2_2>
                                                    <p>Template expressions are similar to JavaScript. Many JavaScript expressions are legal template expressions, with the following exceptions.</p>

                                                    <p>You can't use JavaScript expressions that have or promote side effects, including:</p>
                                                    <ul>
                                                        <li>Assignments (=, +=, -=, ...)</li>
                                                        <li>Operators such as new, typeof, or instanceof</li>
                                                        <li>Chaining expressions with ; or ,</li>
                                                        <li>The increment and decrement operators ++ and --</li>
                                                        <li>Some of the ES2015+ operators</li>
                                                    </ul>

                                                    <p>Other notable differences from JavaScript syntax include:</p>
                                                    <ul>
                                                        <li>No support for the bitwise operators such as | and &</li>
                                                        <li>New template expression operators, such as |, ?. and !</li>
                                                    </ul>
                                                </ng-container>
                                            </ng-container>
                                        </mat-expansion-panel>
                                    </mat-accordion>
                                </ng-container>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Expression context
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>Interpolated expressions have a context—a particular part of the application to which the expression belongs. Typically, this context is the component instance.</p>

                                <p>In the following snippet, the expression recommended and the expression itemImageUrl2 refer to properties of the AppComponent.</p>
                                <code-example code="
                                    < h4>{recommended}</h4>
                                    < img [src]='itemImageUrl2'>
                                "></code-example>

                                <p>An expression can also refer to properties of the template's context such as a template input variable or a template reference variable.</p>
                                <p>The following example uses a template input variable of customer.</p>
                                <code-example code="
                                    < ul>
                                        < li *ngFor='let customer of customers'>{customer.name}</li>
                                     </ul>
                                "></code-example>

                                <p>This next example features a template reference variable, #customerInput.</p>
                                <code-example code="
                                    < label>Type something:
                                        < input #customerInput>{customerInput.value}
                                    </label>
                                "></code-example>

                                <p class="notes">Template expressions cannot refer to anything in the global namespace, except undefined. They can't refer to window or document. Additionally, they can't call console.log() or Math.max() and they are restricted to referencing members of the expression context.</p>


                                <h3>Preventing name collisions</h3>
                                <p>The context against which an expression evaluates is the union of the template variables, the directive's context object—if it has one—and the component's members. If you reference a name that belongs to more than one of these namespaces, Angular applies the following logic to determine the context:</p>
                                <ol>
                                    <li>The template variable name.</li>
                                    <li>A name in the directive's context.</li>
                                    <li>The component's member names.</li>
                                </ol>

                                <p>To avoid variables shadowing variables in another context, keep variable names unique. In the following example, the AppComponent template greets the customer, Padma.</p>
                                <p>An ngFor then lists each customer in the customers array.</p>
                                <code-example code="
                                    @Component({
                                        template: `
                                        < div>
                                            < !-- Hello, Padma -->
                                            < h1>Hello, {customer}</h1>
                                            < ul>
                                            < !-- Ebony and Chiho in a list-->
                                            < li *ngFor='let customer of customers'>{ customer.value }</li>
                                            </ul>
                                        </div>
                                        `
                                    })
                                    class AppComponent {
                                        customers = [{value: 'Ebony'}, {value: 'Chiho'}];
                                        customer = 'Padma';
                                    }
                                "></code-example>

                                <p>The customer within the ngFor is in the context of an < ng-template> and so refers to the customer in the customers array, in this case Ebony and Chiho. This list does not feature Padma because customer outside of the ngFor is in a different context. Conversely, customer in the < h1> doesn't include Ebony or Chiho because the context for this customer is the class and the class value for customer is Padma.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Expression best practices
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content4Content>
                            <ng-container #description_4>
                                <p>When using template expressions, follow these best practices:</p>
                                <ul>
                                    <li>
                                        <p>Use short expressions</p>
                                        <p>Use property names or method calls whenever possible. Keep application and business logic in the component, where it is accessible to develop and test.</p>
                                    </li>
                                    <li>
                                        <p>Quick execution</p>
                                        <p>Angular executes template expressions after every change detection cycle. Many asynchronous activities trigger change detection cycles, such as promise resolutions, HTTP results, timer events, key presses and mouse moves. Expressions should finish quickly to keep the user experience as efficient as possible, especially on slower devices. Consider caching values when their computation requires greater resources.</p>
                                    </li>
                                    <li>
                                        <p>No visible side effects</p>
                                        <p>According to Angular's unidirectional data flow model, a template expression should not change any application state other than the value of the target property. Reading a component value should not change some other displayed value. The view should be stable throughout a single rendering pass.</p>
                                    </li>
                                </ul>

                                <p class="notes">
                                    <span>IDEMPOTENT EXPRESSIONS REDUCE SIDE EFFECTS</span>
                                    <span>An idempotent expression is free of side effects and improves Angular's change detection performance. In Angular terms, an idempotent expression always returns exactly the same thing until one of its dependent values changes.</span>
                                    <span>Dependent values should not change during a single turn of the event loop. If an idempotent expression returns a string or a number, it returns the same string or number if you call it twice consecutively. If the expression returns an object, including an array, it returns the same object reference if you call it twice consecutively.</span>
                                </p>

                                <p class="notes">
                                    There is one exception to this behavior that applies to *ngFor. *ngFor has trackBy functionality that can deal with changing values in objects when iterating over them. See *ngFor with trackBy for details.
                                </p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #templateStatementsTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Template statements
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Template statements are methods or properties that you can use in your HTML to respond to user events. With template statements, your application can engage users through actions such as displaying dynamic content or submitting forms.</p>

                <p>In the following example, the template statement deleteHero() appears in quotes to the right of the = symbol as in (event)="statement".</p>
                <code-example code="
                    < button (click)='deleteHero()'>Delete hero</button>
                "></code-example>

                <p>When the user clicks the Delete hero button, Angular calls the deleteHero() method in the component class.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Syntax
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>Like template expressions, template statements use a language that looks like JavaScript. However, the parser for template statements differs from the parser for template expressions. In addition, the template statements parser specifically supports both basic assignment, =, and chaining expressions with semicolons, ;.</p>

                                <p>The following JavaScript and template expression syntax is not allowed:</p>
                                <ul>
                                    <li>new</li>
                                    <li>increment and decrement operators, ++ and --</li>
                                    <li>operator assignment, such as += and -=</li>
                                    <li>the bitwise operators, such as | and &</li>
                                    <li>the pipe operator</li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Statement context
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Statements have a context—a particular part of the application to which the statement belongs.</p>
                                <p>Statements can refer only to what's in the statement context, which is typically the component instance. For example, deleteHero() of (click)="deleteHero()" is a method of the component in the following snippet.</p>
                                <code-example code="
                                    < button (click)='deleteHero()'>Delete hero</button>
                                "></code-example>

                                <p>The statement context may also refer to properties of the template's own context. In the following example, the component's event handling method, onSave() takes the template's own $event object as an argument. On the next two lines, the deleteHero() method takes a template input variable, hero, and onSubmit() takes a template reference variable, #heroForm.</p>
                                <code-example code="
                                    < button (click)='onSave($event)'>Save</button>
                                    <b utton *ngFor='let hero of heroes' (click)='deleteHero(hero)'>{hero.name}</button>
                                    < form #heroForm (ngSubmit)='onSubmit(heroForm)'> ... </form>
                                "></code-example>

                                <p>In this example, the context of the $event object, hero, and #heroForm is the template.</p>
                                <p>Template context names take precedence over component context names. In the preceding deleteHero(hero), the hero is the template input variable, not the component's hero property.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Statement best practices
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <ul>
                                    <li>
                                        <p>Conciseness</p>
                                        <p>Use method calls or basic property assignments to keep template statements minimal.</p>
                                    </li>
                                    <li>
                                        <p>Work within the context</p>
                                        <p>The context of a template statement can be the component class instance or the template. Because of this, template statements cannot refer to anything in the global namespace such as window or document. For example, template statements can't call console.log() or Math.max().</p>
                                    </li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #pipesTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Pipes
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Use pipes to transform strings, currency amounts, dates, and other data for display. Pipes are simple functions to use in template expressions to accept an input value and return a transformed value. Pipes are useful because you can use them throughout your application, while only declaring each pipe once.</p>
                <p>For example, you would use a pipe to show a date as April 15, 1988 rather than the raw string format.</p>

                <p>Angular provides built-in pipes for typical data transformations, including transformations for internationalization (i18n), which use locale information to format data. The following are commonly used built-in pipes for data formatting:</p>
                <ul>
                    <li>DatePipe: Formats a date value according to locale rules.</li>
                    <li>UpperCasePipe: Transforms text to all upper case.</li>
                    <li>LowerCasePipe: Transforms text to all lower case.</li>
                    <li>CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.</li>
                    <li>DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.</li>
                    <li>PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.</li>
                </ul>

                <p>Create pipes to encapsulate custom transformations and use your custom pipes in template expressions.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Prerequisites
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>To use pipes you should have a basic understanding of the following:</p>
                                <ul>
                                    <li>Typescript and HTML5 programming</li>
                                    <li>Templates in HTML with CSS styles</li>
                                    <li>Components</li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Pipe in a template
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>To apply a pipe, use the pipe operator (|) within a template expression as shown in the following code example, along with the name of the pipe, which is date for the built-in DatePipe. The tabs in the example show the following:</p>
                                <ul>
                                    <li>app.component.html uses date in a separate template to display a birthday.</li>
                                    <li>hero-birthday1.component.ts uses the same pipe as part of an in-line template in a component that also sets the birthday value.</li>
                                </ul>

                                <code-example code="
                                    < p>The hero's birthday is { birthday | date }</p>
                                "></code-example>

                                <code-example code="
                                    import { Component } from '@angular/core';

                                    @Component({
                                        selector: 'app-hero-birthday',
                                        template: `<p>The hero's birthday is { birthday | date }</p>`
                                    })
                                    export class HeroBirthdayComponent {
                                        birthday = new Date(1988, 3, 15); // April 15, 1988 -- since month parameter is zero-based
                                    }
                                "></code-example>

                                <p>The component's birthday value flows through the pipe operator, | to the date function.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Transforming data with parameters and chained pipes
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>Use optional parameters to fine-tune a pipe's output. For example, use the CurrencyPipe with a country code such as EUR as a parameter. The template expression {{ "{{ amount | currency:'EUR' }}" }} transforms the amount to currency in euros. Follow the pipe name (currency) with a colon (:) and the parameter value ('EUR').</p>
                                <p>If the pipe accepts multiple parameters, separate the values with colons. For example, {{ "{{ amount | currency:'EUR':'Euros '}}" }} adds the second parameter, the string literal 'Euros ', to the output string. Use any valid template expression as a parameter, such as a string literal or a component property.</p>
                                <p>Some pipes require at least one parameter and allow more optional parameters, such as SlicePipe. For example, {{ "{{ slice:1:5 }}" }} creates a new array or string containing a subset of the elements starting with element 1 and ending with element 5.</p>
                                <hr>
                                <h3>Example: Formatting a date</h3>
                                <p>The tabs in the following example demonstrates toggling between two different formats ('shortDate' and 'fullDate'):</p>
                                <ul>
                                    <li>The app.component.html template uses a format parameter for the DatePipe (named date) to show the date as 04/15/88.</li>
                                    <li>The hero-birthday2.component.ts component binds the pipe's format parameter to the component's format property in the template section, and adds a button for a click event bound to the component's toggleFormat() method.</li>
                                    <li>The hero-birthday2.component.ts component's toggleFormat() method toggles the component's format property between a short form ('shortDate') and a longer form ('fullDate').</li>
                                </ul>

                                <code-example code="
                                    < p>The hero's birthday is { birthday | date:'MM/dd/yy' } </p>
                                "></code-example>

                                <code-example code="
                                    template: `
                                        < p>The hero's birthday is { birthday | date:format }</p>
                                        < button (click)='toggleFormat()'>Toggle Format</button>
                                    `
                                "></code-example>

                                <code-example code="
                                    export class HeroBirthday2Component {
                                        birthday = new Date(1988, 3, 15); // April 15, 1988 -- since month parameter is zero-based
                                        toggle = true; // start with true == shortDate
                                    
                                        get format()   { return this.toggle ? 'shortDate' : 'fullDate'; }
                                        toggleFormat() { this.toggle = !this.toggle; }
                                    }
                                "></code-example>
                                <p>Clicking the Toggle Format button alternates the date format between 04/15/1988 and Friday, April 15, 1988.</p>
                                <hr>
                                <h3>Example: Applying two formats by chaining pipes</h3>
                                <p>Chain pipes so that the output of one pipe becomes the input to the next.</p>
                                <p>In the following example, chained pipes first apply a format to a date value, then convert the formatted date to uppercase characters. The first tab for the src/app/app.component.html template chains DatePipe and UpperCasePipe to display the birthday as APR 15, 1988. The second tab for the src/app/app.component.html template passes the fullDate parameter to date before chaining to uppercase, which produces FRIDAY, APRIL 15, 1988.</p>
                                <code-example code="
                                    The chained hero's birthday is
                                    { birthday | date | uppercase}
                                "></code-example>

                                <code-example code="
                                    The chained hero's birthday is
                                    {  birthday | date:'fullDate' | uppercase}
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Creating pipes for custom data transformations
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content4Content>
                            <ng-container #description_4>
                                <p>Create custom pipes to encapsulate transformations that are not provided with the built-in pipes. Then, use your custom pipe in template expressions, the same way you use built-in pipes—to transform input values to output values for display.</p>
                                <br>
                                <hr>
                                <h3>Marking a class as a pipe</h3>
                                <p>To mark a class as a pipe and supply configuration metadata, apply the @Pipe decorator to the class. Use UpperCamelCase (the general convention for class names) for the pipe class name, and camelCase for the corresponding name string. Do not use hyphens in the name. For details and more examples, see Pipe names.</p>
                                <p>Use name in template expressions as you would for a built-in pipe.</p>
                                <span class="notes">
                                    <ul>
                                        <li>Include your pipe in the declarations field of the NgModule metadata in order for it to be available to a template. See the app.module.ts file in the example application (live example / download example). For details, see NgModules.</li>
                                        <li>Register your custom pipes. The Angular CLI ng generate pipe command registers the pipe automatically.</li>
                                    </ul>
                                </span>
                                <br>
                                <hr>
                                <h3>Using the PipeTransform interface</h3>
                                <p>Implement the PipeTransform interface in your custom pipe class to perform the transformation.</p>
                                <p>Angular invokes the transform method with the value of a binding as the first argument, and any parameters as the second argument in list form, and returns the transformed value.</p>
                                <br>
                                <hr>
                                <h3>Example: Transforming a value exponentially</h3>
                                <p>In a game, you might want to implement a transformation that raises a value exponentially to increase a hero's power. For example, if the hero's score is 2, boosting the hero's power exponentially by 10 produces a score of 1024. Use a custom pipe for this transformation.</p>
                                <p>The following code example shows two component definitions:</p>
                                <ul>
                                    <li>The exponential-strength.pipe.ts component defines a custom pipe named exponentialStrength with the transform method that performs the transformation. It defines an argument to the transform method (exponent) for a parameter passed to the pipe.</li>
                                    <li>The power-booster.component.ts component demonstrates how to use the pipe, specifying a value (2) and the exponent parameter (10).</li>
                                </ul>
                                <code-example code="
                                    import { Pipe, PipeTransform } from '@angular/core';
                                    /*
                                    * Raise the value exponentially
                                    * Takes an exponent argument that defaults to 1.
                                    * Usage:
                                    *   value | exponentialStrength:exponent
                                    * Example:
                                    *   { 2 | exponentialStrength:10 }
                                    *   formats to: 1024
                                    */
                                    @Pipe({name: 'exponentialStrength'})
                                    export class ExponentialStrengthPipe implements PipeTransform {
                                        transform(value: number, exponent = 1): number {
                                            return Math.pow(value, exponent);
                                        }
                                    }
                                "></code-example>

                                <code-example code="
                                    import { Component } from '@angular/core';

                                    @Component({
                                        selector: 'app-power-booster',
                                        template: `
                                            < h2>Power Booster</h2>
                                            < p>Super power boost: {2 | exponentialStrength: 10}</p>
                                        `
                                        })
                                    export class PowerBoosterComponent { }
                                "></code-example>
                                
                                <p>The browser displays the following:</p>
                                <code-example code="
                                    Power Booster

                                    Superpower boost: 1024
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Detecting changes with data binding in pipes
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content5Content>
                            <ng-container #description_5>
                                <p>You use data binding with a pipe to display values and respond to user actions. If the data is a primitive input value, such as String or Number, or an object reference as input, such as Date or Array, Angular executes the pipe whenever it detects a change for the input value or reference.</p>
                                <p>For example, you could change the previous custom pipe example to use two-way data binding with ngModel to input the amount and boost factor, as shown in the following code example.</p>
                                <code-example code="
                                    import { Component } from '@angular/core';

                                    @Component({
                                        selector: 'app-power-boost-calculator',
                                        template: `
                                            < h2>Power Boost Calculator</h2>
                                            < label for='power-input'>Normal power: </label>
                                            < input id='power-input' type='text' [(ngModel)]='power'>
                                            < label for='boost-input'>Boost factor: </label>
                                            < input id='boost-input' type='text' [(ngModel)]='factor'>
                                            < p>
                                                Super Hero Power: {power | exponentialStrength: factor}
                                            </p>
                                        `,
                                        styles: ['input {margin: .5rem 0;}']
                                    })
                                    export class PowerBoostCalculatorComponent {
                                        power = 5;
                                        factor = 1;
                                    }
                                "></code-example>

                                <p>The exponentialStrength pipe executes every time the user changes the "normal power" value or the "boost factor".</p>
                                <p>Angular detects each change and immediately runs the pipe. This is fine for primitive input values. However, if you change something inside a composite object (such as the month of a date, an element of an array, or an object property), you need to understand how change detection works, and how to use an impure pipe.</p>
                            </ng-container>

                            <ng-container #content5_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                How change detection works
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_1_Inner>
                                            <p>Angular looks for changes to data-bound values in a change detection process that runs after every DOM event: every keystroke, mouse move, timer tick, and server response. The following example, which doesn't use a pipe, demonstrates how Angular uses its default change detection strategy to monitor and update its display of every hero in the heroes array. The example tabs show the following:</p>
                                            <ul>
                                                <li>In the flying-heroes.component.html (v1) template, the *ngFor repeater displays the hero names.</li>
                                                <li>Its companion component class flying-heroes.component.ts (v1) provides heroes, adds heroes into the array, and resets the array.</li>
                                            </ul>

                                            <code-example code="
                                                < label for='hero-name'>New hero name: </label>
                                                < input type='text' #box
                                                    id='hero-name'
                                                    (keyup.enter)='addHero(box.value); box.value='''
                                                    placeholder='hero name'>
                                                < button (click)='reset()'>Reset list of heroes</button>
                                                < div *ngFor='let hero of heroes'>
                                                    {hero.name}
                                                </div>
                                            "></code-example>

                                            <code-example code="
                                                export class FlyingHeroesComponent {
                                                    heroes: any[] = [];
                                                    canFly = true;
                                                    constructor() { this.reset(); }
                                                
                                                    addHero(name: string) {
                                                    name = name.trim();
                                                    if (!name) { return; }
                                                    const hero = {name, canFly: this.canFly};
                                                    this.heroes.push(hero);
                                                    }
                                                
                                                    reset() { this.heroes = HEROES.slice(); }
                                                }
                                            "></code-example>

                                            <p>Angular updates the display every time the user adds a hero. If the user clicks the Reset button, Angular replaces heroes with a new array of the original heroes and updates the display. If you add the ability to remove or change a hero, Angular would detect those changes and update the display as well.</p>
                                            <p>However, executing a pipe to update the display with every change would slow down your application's performance. So Angular uses a faster change-detection algorithm for executing a pipe, as described in the next section.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content5_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Detecting pure changes to primitives and object references
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_2_Inner>
                                            <p>By default, pipes are defined as pure so that Angular executes the pipe only when it detects a pure change to the input value. A pure change is either a change to a primitive input value (such as String, Number, Boolean, or Symbol), or a changed object reference (such as Date, Array, Function, or Object).</p>
                                            <p>A pure pipe must use a pure function, which is one that processes inputs and returns values without side effects. In other words, given the same input, a pure function should always return the same output.</p>
                                            <p>With a pure pipe, Angular ignores changes within composite objects, such as a newly added element of an existing array, because checking a primitive value or object reference is much faster than performing a deep check for differences within objects. Angular can quickly determine if it can skip executing the pipe and updating the view.</p>
                                            <p>However, a pure pipe with an array as input might not work the way you want. To demonstrate this issue, change the previous example to filter the list of heroes to just those heroes who can fly. Use the FlyingHeroesPipe in the *ngFor repeater as shown in the following code. The tabs for the example show the following:</p>
                                            <ul>
                                                <li>The template (flying-heroes.component.html (flyers)) with the new pipe.</li>
                                                <li>The FlyingHeroesPipe custom pipe implementation (flying-heroes.pipe.ts).</li>
                                            </ul>
                                            <code-example code="
                                                < div *ngFor='let hero of (heroes | flyingHeroes)'>
                                                    {hero.name}
                                                </div>
                                            "></code-example>

                                            <code-example code="
                                                import { Pipe, PipeTransform } from '@angular/core';

                                                import { Hero } from './heroes';
                                                
                                                @Pipe({ name: 'flyingHeroes' })
                                                export class FlyingHeroesPipe implements PipeTransform {
                                                    transform(allHeroes: Hero[]) {
                                                        return allHeroes.filter(hero => hero.canFly);
                                                    }
                                                }
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content5_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Detecting impure changes within composite objects
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_3_Inner>
                                            <p>To execute a custom pipe after a change within a composite object, such as a change to an element of an array, you need to define your pipe as impure to detect impure changes. Angular executes an impure pipe every time it detects a change with every keystroke or mouse movement.</p>
                                            <p class="notes">
                                                While an impure pipe can be useful, be careful using one. A long-running impure pipe could dramatically slow down your application.
                                            </p>

                                            <p>
                                                Make a pipe impure by setting its pure flag to false:
                                            </p>
                                            <code-example code="
                                                @Pipe({
                                                    name: 'flyingHeroesImpure',
                                                    pure: false
                                                })
                                            "></code-example>

                                            <p>The following code shows the complete implementation of FlyingHeroesImpurePipe, which extends FlyingHeroesPipe to inherit its characteristics. The example shows that you don't have to change anything else—the only difference is setting the pure flag as false in the pipe metadata.</p>
                                            <code-example code="
                                                @Pipe({
                                                    name: 'flyingHeroesImpure',
                                                    pure: false
                                                })
                                                export class FlyingHeroesImpurePipe extends FlyingHeroesPipe {}
                                            "></code-example>

                                            <code-example code="
                                                import { Pipe, PipeTransform } from '@angular/core';

                                                import { Hero } from './heroes';
                                                
                                                @Pipe({ name: 'flyingHeroes' })
                                                export class FlyingHeroesPipe implements PipeTransform {
                                                    transform(allHeroes: Hero[]) {
                                                        return allHeroes.filter(hero => hero.canFly);
                                                    }
                                                }
                                            "></code-example>

                                            <p>FlyingHeroesImpurePipe is a good candidate for an impure pipe because the transform function is trivial and fast:</p>
                                            <code-example code="
                                                return allHeroes.filter(hero => hero.canFly);
                                            "></code-example>

                                            <p>You can derive a FlyingHeroesImpureComponent from FlyingHeroesComponent. As shown in the following code, only the pipe in the template changes.</p>
                                            <code-example code="
                                                < div *ngFor='let hero of (heroes | flyingHeroesImpure)'>
                                                    {hero.name}
                                                </div>
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content6>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Unwrapping data from an observable
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content6Content>
                            <ng-container #description_6>
                                <p>Observables let you pass messages between parts of your application. Observables are recommended for event handling, asynchronous programming, and handling multiple values. Observables can deliver single or multiple values of any type, either synchronously (as a function delivers a value to its caller) or asynchronously on a schedule.</p>
                                <p>Use the built-in AsyncPipe to accept an observable as input and subscribe to the input automatically. Without this pipe, your component code would have to subscribe to the observable to consume its values, extract the resolved values, expose them for binding, and unsubscribe when the observable is destroyed in order to prevent memory leaks. AsyncPipe is an impure pipe that saves boilerplate code in your component to maintain the subscription and keep delivering values from that observable as they arrive.</p>
                                <p>The following code example binds an observable of message strings (message$) to a view with the async pipe.</p>
                                <code-example code="
                                    import { Component } from '@angular/core';

                                    import { Observable, interval } from 'rxjs';
                                    import { map, take } from 'rxjs/operators';
                                    
                                    @Component({
                                    selector: 'app-hero-async-message',
                                    template: `
                                        < h2>Async Hero Message and AsyncPipe</h2>
                                        < p>Message: { message$ | async }</p>
                                        < button (click)='resend()'>Resend</button>`,
                                    })
                                    export class HeroAsyncMessageComponent {
                                    message$: Observable<string>;
                                    
                                    private messages = [
                                        'You are my hero!',
                                        'You are the best hero!',
                                        'Will you be my hero?'
                                    ];
                                    
                                    constructor() {
                                        this.message$ = this.getResendObservable();
                                    }
                                    
                                    resend() {
                                        this.message$ = this.getResendObservable();
                                    }
                                    
                                    private getResendObservable() {
                                        return interval(500).pipe(
                                        map(i => this.messages[i]),
                                        take(this.messages.length)
                                        );
                                    }
                                    }
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content7>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Caching HTTP requests
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content7Content>
                            <ng-container #description_7>
                                <p>To communicate with backend services using HTTP, the HttpClient service uses observables and offers the HttpClient.get() method to fetch data from a server. The asynchronous method sends an HTTP request, and returns an observable that emits the requested data for the response.</p>
                                <p>As shown in the previous section, use the impure AsyncPipe to accept an observable as input and subscribe to the input automatically. You can also create an impure pipe to make and cache an HTTP request.</p>
                                <p>Impure pipes are called whenever change detection runs for a component, which could be as often as every few milliseconds. To avoid performance problems, call the server only when the requested URL changes, as shown in the following example, and use the pipe to cache the server response. The tabs show the following:</p>
                                <ul>
                                    <li>The fetch pipe (fetch-json.pipe.ts).</li>
                                    <li>A harness component (hero-list.component.ts) for demonstrating the request, using a template that defines two bindings to the pipe requesting the heroes from the heroes.json file. The second binding chains the fetch pipe with the built-in JsonPipe to display the same hero data in JSON format.</li>
                                </ul>
                                <code-example code="
                                    import { HttpClient } from '@angular/common/http';
                                    import { Pipe, PipeTransform } from '@angular/core';
                                    
                                    @Pipe({
                                        name: 'fetch',
                                        pure: false
                                    })
                                    export class FetchJsonPipe implements PipeTransform {
                                        private cachedData: any = null;
                                        private cachedUrl = '';
                                        
                                        constructor(private http: HttpClient) { }
                                        
                                        transform(url: string): any {
                                            if (url !== this.cachedUrl) {
                                            this.cachedData = null;
                                            this.cachedUrl = url;
                                            this.http.get(url).subscribe(result => this.cachedData = result);
                                            }
                                        
                                            return this.cachedData;
                                        }
                                    }
                                "></code-example>

                                <code-example code="
                                    import { Component } from '@angular/core';

                                    @Component({
                                    selector: 'app-hero-list',
                                    template: `
                                        < h2>Heroes from JSON File</h2>
                                    
                                        < div *ngFor='let hero of ('assets/heroes.json' | fetch) '>
                                            {hero.name}
                                        </div>
                                    
                                        <p>Heroes as JSON:
                                         {'assets/heroes.json' | fetch | json}
                                        </p>`
                                    })
                                    export class HeroListComponent { }
                                "></code-example>

                                <p>In the preceding example, a breakpoint on the pipe's request for data shows the following:</p>
                                <ul>
                                    <li>Each binding gets its own pipe instance.</li>
                                    <li>Each pipe instance caches its own URL and data and calls the server only once.</li>
                                </ul>
                                <p>The fetch and fetch-json pipes display the heroes in the browser as follows:</p>
                                <code-example code="
                                    Heroes from JSON File

                                    Windstorm
                                    Bombasto
                                    Magneto
                                    Tornado
                                    
                                    Heroes as JSON: [ { 'name': 'Windstorm', 'canFly': true }, { 'name': 'Bombasto', 'canFly': false }, { 'name': 'Magneto', 'canFly': false }, { 'name': 'Tornado', 'canFly': true } ]
                                "></code-example>

                                <p class="notes">The built-in JsonPipe provides a way to diagnose a mysteriously failing data binding or to inspect an object for future binding.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content8>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Pipes and precedence
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content8Content>
                            <ng-container #description_8>
                                <p>The pipe operator has a higher precedence than the ternary operator (?:), which means a ? b : c | x is parsed as a ? b : (c | x). The pipe operator cannot be used without parentheses in the first and second operands of ?:.</p>
                                <p>Due to precedence, if you want a pipe to apply to the result of a ternary, wrap the entire expression in parentheses; for example, (a ? b : c) | x.</p>
                                <code-example code="
                                    < !-- use parentheses in the third operand so the pipe applies to the whole expression -->
                                    { (true ? 'true' : 'false') | uppercase }
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #propertyBindingTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Property binding
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Property binding in Angular helps you set values for properties of HTML elements or directives. Use property binding to do things such as toggle button functionality, set paths programmatically, and share values between components.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Prerequisites
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>To get the most out of property binding, you should be familiar with the following:</p>
                                <ul>
                                    <li>Basics of components</li>
                                    <li>Basics of templates</li>
                                    <li>Binding syntax</li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Understanding the flow of data
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Property binding moves a value in one direction, from a component's property into a target element property.</p>
                                <p>To read a target element property or call one of its methods, see the API reference for ViewChild and ContentChild.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to a property
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>To bind to an element's property, enclose it in square brackets, [], which identifies the property as a target property. A target property is the DOM property to which you want to assign a value.</p>
                                <p>For example, the target property in the following code is the image element's src property.</p>
                                <code-example code="
                                    < img [src]='itemImageUrl'>
                                "></code-example>

                                <p>In most cases, the target name is the name of a property, even when it appears to be the name of an attribute. In this example, src is the name of the < img> element property.</p>
                                <p>The brackets, [], cause Angular to evaluate the right-hand side of the assignment as a dynamic expression. Without the brackets, Angular treats the right-hand side as a string literal and sets the property to that static value.</p>
                                <code-example code="
                                    < app-item-detail childItem='parentItem'></app-item-detail>
                                "></code-example>

                                <p>Omitting the brackets renders the string parentItem, not the value of parentItem.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Setting an element property to a component property value
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content4Content>
                            <ng-container #description_4>
                                <p>To bind the src property of an <img> element to a component's property, place the target, src, in square brackets followed by an equal sign and then the property. The property here is itemImageUrl.</p>
                                <code-example code="
                                    < img [src]='itemImageUrl'>
                                "></code-example>

                                <p>Declare the itemImageUrl property in the class, in this case AppComponent.</p>
                                <code-example code="
                                    itemImageUrl = '../assets/phone.png';
                                "></code-example>

                                <h3>colspan and colSpan</h3>
                                <p>A common point of confusion is between the attribute, colspan, and the property, colSpan. Notice that these two names differ by only a single letter.</p>
                                <p>If you wrote something like this:</p>
                                <code-example code="
                                    < tr>< td colspan='{1 + 1}'>Three-Four</td></tr>
                                "></code-example>

                                <p>You'd get this error:</p>
                                <code-example code="
                                    Template parse errors:
                                    Can't bind to 'colspan' because it isn't a known built-in property
                                "></code-example>

                                <p>As the message says, the <td> element does not have a colspan property. This is true because colspan is an attribute—colSpan, with a capital S, is the corresponding property. Interpolation and property binding can set only properties, not attributes.</p>
                                <p>Instead, you'd use property binding and write it like this:</p>
                                <code-example code="
                                    < !-- Notice the colSpan property is camel case -->
                                    < tr>< td [colSpan]='1 + 1'>Three-Four</td></tr>
                                "></code-example>

                                <p>Another example is disabling a button when the component says that it isUnchanged:</p>
                                <code-example code="
                                    < !-- Bind button disabled state to `isUnchanged` property -->
                                    < button [disabled]='isUnchanged'>Disabled Button</button>
                                "></code-example>

                                <p>Another is setting a property of a directive:</p>
                                <code-example code="
                                    < p [ngClass]='classes'>[ngClass] binding to the classes property making this blue</p>
                                "></code-example>
                                
                                <p>Yet another is setting the model property of a custom component—a great way for parent and child components to communicate:</p>
                                <code-example code="
                                    < app-item-detail [childItem]='parentItem'></app-item-detail>
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Toggling button functionality
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content5Content>
                            <ng-container #description_5>
                                <p>To disable a button's functionality depending on a Boolean value, bind the DOM disabled property to a property in the class that is true or false.</p>
                                <code-example code="
                                    < !-- Bind button disabled state to `isUnchanged` property -->
                                    < button [disabled]='isUnchanged'>Disabled Button</button>
                                "></code-example>

                                <p>Because the value of the property isUnchanged is true in the AppComponent, Angular disables the button.</p>
                                <code-example code="
                                    isUnchanged = true;
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content6>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Setting a directive property
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content6Content>
                            <ng-container #description_6>
                                <p>To set a property of a directive, place the directive within square brackets , such as [ngClass], followed by an equal sign and the property. Here, the property is classes.</p>
                                <code-example code="
                                    < p [ngClass]='classes'>[ngClass] binding to the classes property making this blue</p>
                                "></code-example>

                                <p>To use the property, you must declare it in the class, which in this example is AppComponent. The value of classes is special.</p>
                                <code-example code="
                                    classes = 'special';
                                "></code-example>

                                <p>Angular applies the class special to the <p> element so that you can use special to apply CSS styles.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content7>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Bind values between components
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content7Content>
                            <ng-container #description_7>
                                <p>To set the model property of a custom component, place the target, here childItem, between square brackets [] followed by an equal sign and the property. Here, the property is parentItem.</p>
                                <code-example code="
                                    < app-item-detail [childItem]='parentItem'></app-item-detail>
                                "></code-example>

                                <p>To use the target and the property, you must declare them in their respective classes.</p>
                                <p>Declare the target of childItem in its component class, in this case ItemDetailComponent.</p>
                                <p>For example, the following code declares the target of childItem in its component class, in this case ItemDetailComponent.</p>
                                <p>Then, the code contains an @Input() decorator with the childItem property so data can flow into it.</p>

                                <code-example code="
                                    @Input() childItem = '';
                                "></code-example>

                                <p>Next, the code declares the property of parentItem in its component class, in this case AppComponent. In this example the type of childItem is string, so parentItem needs to be a string. Here, parentItem has the string value of lamp.</p>
                                <code-example code="
                                    parentItem = 'lamp';
                                "></code-example>

                                <p>With this configuration, the view of < app-item-detail> uses the value of lamp for childItem.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content8>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Property binding and security
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content8Content>
                            <ng-container #description_8>
                                <p>Property binding can help keep content secure. For example, consider the following malicious content.</p>
                                <code-example code="
                                    evilTitle = 'Template < script>alert('evil never sleeps')</script> Syntax';
                                "></code-example>

                                <p>The component template interpolates the content as follows:</p>
                                <code-example code="
                                    < p><span>'{evilTitle}' is the <i>interpolated</i> evil title.</span></p>
                                "></code-example>

                                <p>The browser doesn't process the HTML and instead displays it raw, as follows.</p>
                                <code-example code="
                                    'Template < script>alert('evil never sleeps')</script> Syntax' is the interpolated evil title.
                                "></code-example>

                                <p>Angular does not allow HTML with script tags, neither with interpolation nor property binding, which prevents the JavaScript from running.</p>
                                <p>In the following example, however, Angular sanitizes the values before displaying them.</p>
                                <code-example code="
                                    <!--
                                        Angular generates a warning for the following line as it sanitizes them
                                        WARNING: sanitizing HTML stripped some content (see https://g.co/ng/security#xss).
                                   -->
                                    < p>'<span [innerHTML]='evilTitle'></span>' is the <i>property bound</i> evil title.</p>
                                "></code-example>

                                <p>Interpolation handles the script tags differently than property binding, but both approaches render the content harmlessly. The following is the browser output of the sanitized evilTitle example.</p>
                                <code-example code="
                                    'Template Syntax' is the property bound evil title.
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content9>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Property binding and interpolation
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content9Content>
                            <ng-container #description_9>
                                <p>Often interpolation and property binding can achieve the same results. The following binding pairs do the same thing.</p>
                                <code-example code="
                                    < p>< img src='{itemImageUrl}'> is the < i>interpolated</i> image.</p>
                                    < p>< img [src]='itemImageUrl'> is the < i>property bound</i> image.</p>
                                    
                                    < p>< span>'{interpolationTitle}' is the < i>interpolated</i> title.</span></p>
                                    < p>'< span [innerHTML]='propertyTitle'></span>' is the < i>property bound</i> title.</p>
                                "></code-example>

                                <p>Use either form when rendering data values as strings, though interpolation is preferable for readability. However, when setting an element property to a non-string data value, you must use property binding.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #acsBindingsTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Attribute, class, and style bindings
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Attribute binding in Angular helps you set values for attributes directly. With attribute binding, you can improve accessibility, style your application dynamically, and manage multiple CSS classes or styles simultaneously.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to an attribute
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>It is recommended that you set an element property with a property binding whenever possible. However, sometimes you don't have an element property to bind. In those situations, use attribute binding.</p>
                                <p>For example, ARIA and SVG are purely attributes. Neither ARIA nor SVG correspond to element properties and don't set element properties. In these cases, you must use attribute binding because there are no corresponding property targets.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Syntax
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Attribute binding syntax resembles property binding, but instead of an element property between brackets, you precede the name of the attribute with the prefix attr, followed by a dot. Then, you set the attribute value with an expression that resolves to a string.</p>
                                <code-example code="
                                    < p [attr.attribute-you-are-targeting]='expression'></p>
                                "></code-example>

                                <p class="notes">When the expression resolves to null or undefined, Angular removes the attribute altogether.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding ARIA attributes
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>One of the primary use cases for attribute binding is to set ARIA attributes, as in this example:</p>
                                <code-example code="
                                    < !-- create and set an aria attribute for assistive technology -->
                                    < button [attr.aria-label]='actionName'>{actionName} with Aria</button>
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to colspan
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content4Content>
                            <ng-container #description_4>
                                <p>Another common use case for attribute binding is with the colspan attribute in tables. Binding to the colspan attribute helps you keep your tables programmatically dynamic. Depending on the amount of data that your application populates a table with, the number of columns that a row spans could change.</p>
                                <p>To use attribute binding with the <td> attribute colspan:</p>
                                <ol>
                                    <li>Specify the colspan attribute by using the following syntax: [attr.colspan].</li>
                                    <li>Set [attr.colspan] equal to an expression.</li>
                                </ol>

                                <p>In the following example, you bind the colspan attribute to the expression 1 + 1.</p>
                                <code-example code="
                                    < !--  expression calculates colspan=2 -->
                                    < tr>< td [attr.colspan]='1 + 1'>One-Two</td></tr>
                                "></code-example>

                                <p>This binding causes the < tr> to span two columns.</p>
                                <p class="note">Sometimes there are differences between the name of property and an attribute. colspan is an attribute of < tr>, while colSpan with a capital "S" is a property. When using attribute binding, use colspan with a lowercase "s". For more information on how to bind to the colSpan property, see the colspan and colSpan section of Property Binding.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to the class attribute
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content5Content>
                            <ng-container #description_5>
                                <p>Use class binding to add and remove CSS class names from an element's class attribute.</p>

                                <h3>Binding to a single CSS class</h3>
                                <p>To create a single class binding, use the prefix class followed by a dot and the name of the CSS class—for example, [class.sale]="onSale". Angular adds the class when the bound expression, onSale is truthy, and it removes the class when the expression is falsy—with the exception of undefined. See styling delegation for more information.</p>

                                <br>
                                <h3>Binding to multiple CSS classes</h3>
                                <p>To bind to multiple classes, use [class] set to an expression—for example, [class]="classExpression". The expression can be one of:</p>
                                <ul>
                                    <li>A space-delimited string of class names.</li>
                                    <li>An object with class names as the keys and truthy or falsy expressions as the values.</li>
                                    <li>An array of class names.</li>
                                </ul>

                                <p>With the object format, Angular adds a class only if its associated value is truthy.</p>
                                <p class="note">With any object-like expression—such as object, Array, Map, or Set—the identity of the object must change for Angular to update the class list. Updating the property without changing object identity has no effect.</p>
                                <p>If there are multiple bindings to the same class name, Angular uses styling precedence to determine which binding to use.</p>
                                <p>The following table summarizes class binding syntax.</p>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Binding Type</th>
                                            <th>Syntax</th>
                                            <th>Input Type</th>
                                            <th>Example Input Values</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Single class binding</td>
                                            <td>[class.sale]="onSale"</td>
                                            <td>boolean | undefined | null</td>
                                            <td>true, false</td>
                                        </tr>
                                        <tr>
                                            <td>Multi-class binding</td>
                                            <td>[class]=classExpression</td>
                                            <td>string</td>
                                            <td>my-class-1 my-class-2 my-class-3</td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td></td>
                                            <td>Record string, boolean | undefined | null</td>
                                            <td>foo: true, bar: false</td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td></td>
                                            <td>Array string</td>
                                            <td>['foo', 'bar']</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content6>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to the style attribute
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content6Content>
                            <ng-container #description_6>
                                <p>Use style binding to set styles dynamically.</p>

                                <h3>Binding to a single style</h3>
                                <p>To create a single style binding, use the prefix style followed by a dot and the name of the CSS style property—for example, [style.width]="width". Angular sets the property to the value of the bound expression, which is usually a string. Optionally, you can add a unit extension like em or %, which requires a number type.</p>
                                <p class="note">
                                    You can write a style property name in either dash-case, or camelCase.
                                    <code-example code="
                                        < nav [style.background-color]='expression'></nav>

                                        < nav [style.backgroundColor]='expression'></nav>
                                    "></code-example>
                                </p>

                                <h3>Binding to multiple styles</h3>
                                <p>To toggle multiple styles, bind to the [style] attribute—for example, [style]="styleExpression". The styleExpression can be one of:</p>
                                <ul>
                                    <li>A string list of styles such as "width: 100px; height: 100px; background-color: cornflowerblue;".</li>
                                    <li>An object with style names as the keys and style values as the values, such as width: '100px', height: '100px', backgroundColor: 'cornflowerblue'.</li>
                                </ul>

                                <p>Note that binding an array to [style] is not supported.</p>
                                <p class="notes">When binding [style] to an object expression, the identity of the object must change for Angular to update the class list. Updating the property without changing object identity has no effect.</p>
                           
                                <ng-container #content6_1>
                                    <mat-accordion>
                                        <mat-expansion-panel>
                                            <mat-expansion-panel-header>
                                                <mat-panel-title>
                                                    Single and multiple-style binding example
                                                </mat-panel-title>
                                            </mat-expansion-panel-header>
                            
                                            <ng-container #content6Content>
                                                <ng-container #description_6>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-nav-bar',
                                                        template: `
                                                      < nav [style]='navStyle'>
                                                        < a [style.text-decoration]='activeLinkStyle'>Home Page</a>
                                                        <a [style.text-decoration]='linkStyle'>Login</a>
                                                      </nav>`
                                                      })
                                                      export class NavBarComponent {
                                                        navStyle = 'font-size: 1.2rem; color: cornflowerblue;';
                                                        linkStyle = 'underline';
                                                        activeLinkStyle = 'overline';
                                                        /* . . . */
                                                      }
                                                    "></code-example>

                                                    <p>If there are multiple bindings to the same style attribute, Angular uses styling precedence to determine which binding to use.</p>
                                                    <p>The following table summarizes style binding syntax.</p>

                                                      <table>
                                                          <thead>
                                                              <tr>
                                                                  <th>Binding Type</th>
                                                                  <th>Syntax</th>
                                                                  <th>Input Type</th>
                                                                  <th>Example Input Values</th>
                                                              </tr>
                                                          </thead>
                                                          <tbody>
                                                              <tr>
                                                                <td>Single style binding</td>
                                                                <td>[style.width]=width</td>
                                                                <td>string | undefined | null</td>
                                                                <td>100px</td>
                                                              </tr>
                                                              <tr>
                                                                <td>Single style binding with units</td>
                                                                <td>[style.width.px]=width</td>
                                                                <td>number | undefined | null</td>
                                                                <td>100</td>
                                                              </tr>
                                                              <tr>
                                                                <td>Multi-style binding</td>
                                                                <td>[style]=styleExpression</td>
                                                                <td>string</td>
                                                                <td>width: 100px; height: 100px</td>
                                                              </tr>
                                                              <tr>
                                                                <td></td>
                                                                <td></td>
                                                                <td>Record string, string | undefined | null</td>
                                                                <td>width: '100px', height: '100px'</td>
                                                              </tr>
                                                          </tbody>
                                                      </table>

                                                    <p class="note">The NgStyle directive can be used as an alternative to direct [style] bindings. However, using the preceding style binding syntax without NgStyle is preferred because due to improvements in style binding in Angular, NgStyle no longer provides significant value, and might eventually be removed in the future.</p>
                                                </ng-container>
                                            </ng-container>
                                        </mat-expansion-panel>
                                    </mat-accordion>
                                </ng-container>

                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content7>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Styling Precedence
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content7Content>
                            <ng-container #description_7>
                                <p>A single HTML element can have its CSS class list and style values bound to multiple sources (for example, host bindings from multiple directives).</p>
                                <p>When there are multiple bindings to the same class name or style property, Angular uses a set of precedence rules to resolve conflicts and determine which classes or styles are ultimately applied to the element.</p>
                                <span class="note">
                                    <h3>Styling precedence (highest to lowest)</h3>
                                    <ol>
                                        <li>
                                            <p>Template bindings</p>
                                            <ol type="a">
                                                <li>Property binding (for example, < div [class.foo]="hasFoo"> or < div [style.color]="color">)</li>
                                                <li>Map binding (for example, < div [class]="classExpr"> or < div [style]="styleExpr">)</li>
                                                <li>Static value (for example, < div class="foo"> or < div style="color: blue">)</li>
                                            </ol>
                                        </li>
                                        <li>
                                            <p>Directive host bindings</p>
                                            <ol type="a">
                                                <li>Property binding (for example, host: '[class.foo]': 'hasFoo' or host: '[style.color]': 'color')</li>
                                                <li>Map binding (for example, host: '[class]': 'classExpr' or host: '[style]': 'styleExpr')</li>
                                                <li>Static value (for example, host: 'class': 'foo' or host: 'style': 'color: blue')</li>
                                            </ol>
                                        </li>
                                        <li>
                                            <p>Component host bindings</p>
                                            <ol type="a">
                                                <li>Property binding (for example, host: '[class.foo]': 'hasFoo' or host: '[style.color]': 'color')</li>
                                                <li>Map binding (for example, host: '[class]': 'classExpr' or host: '[style]': 'styleExpr')</li>
                                                <li>Static value (for example, host: 'class': 'foo' or host: 'style': 'color: blue')</li>
                                            </ol>
                                        </li>
                                    </ol>
                                </span>

                                <p>The more specific a class or style binding is, the higher its precedence.</p>

                                <p>A binding to a specific class (for example, [class.foo]) takes precedence over a generic [class] binding, and a binding to a specific style (for example, [style.bar]) takes precedence over a generic [style] binding.</p>

                                <code-example code="
                                    < h3>Basic specificity</h3>

                                    < !-- The `class.special` binding overrides any value for the `special` class in `classExpression`.  -->
                                    < div [class.special]='isSpecial' [class]='classExpression'>Some text.</div>
                                    
                                    <!-- The `style.border` binding overrides any value for the `border` property in `styleExpression`.  -->
                                    < div [style.border]='border' [style]='styleExpression'>Some text.</div>
                                "></code-example>

                                <p>Specificity rules also apply when it comes to bindings that originate from different sources. It's possible for an element to have bindings in the template where it's declared, from host bindings on matched directives, and from host bindings on matched components.</p>

                                <p>Template bindings are the most specific because they apply to the element directly and exclusively, so they have the highest precedence.</p>
                                <p>Directive host bindings are considered less specific because directives can be used in multiple locations, so they have a lower precedence than template bindings.</p>
                                <p>Directives often augment component behavior, so host bindings from components have the lowest precedence.</p>

                                <code-example code="
                                    < h3>Source specificity</h3>

                                    < !-- The `class.special` template binding overrides any host binding to the `special` class set by `dirWithClassBinding` or `comp-with-host-binding`.-->
                                    
                                    < comp-with-host-binding [class.special]='isSpecial' dirWithClassBinding></comp-with-host-binding>
                                    
                                    
                                    <!-- The `style.color` template binding overrides any host binding to the `color` property set by `dirWithStyleBinding` or `comp-with-host-binding`. -->
                                    < div>
                                    < comp-with-host-binding [style.color]='color' dirWithStyleBinding></comp-with-host-binding>
                                    </div>
                                    
                                    < h3>Dynamic vs static</h3>
                                    
                                    <!-- If `classExpression` has a value for the `special` class, this value overrides the `class='special'` below -->
                                    < div class='special' [class]='classExpression'>Some text.</div>
                                    
                                    <!-- If `styleExpression` has a value for the `border` property, this value overrides the `style='border: dotted darkblue 3px'` below -->
                                    < div style='border: dotted darkblue 3px' [style]='styleExpression'>Some text.</div>
                                    
                                    
                                    < div class='readability'>
                                    < comp-with-host-binding dirWithHostBinding></comp-with-host-binding>
                                    </div>
                                    
                                    < app-my-input-with-attribute-decorator type='number'></app-my-input-with-attribute-decorator>
                                "></code-example>

                                <p>In addition, bindings take precedence over static attributes.</p>

                                <p>In the following case, class and [class] have similar specificity, but the [class] binding takes precedence because it is dynamic.</p>

                                <code-example code="
                                    < h3>Dynamic vs static</h3>

                                    < !-- If `classExpression` has a value for the `special` class, this value overrides the `class='special'` below -->
                                    < div class='special' [class]='lassExpression'>Some text.</div>
                                    
                                    <!-- If `styleExpression` has a value for the `border` property, this value overrides the `style='border: dotted darkblue 3px'` below -->
                                    < div style='border: dotted darkblue 3px' [style]='styleExpression'>Some text.</div>
                                "></code-example>

                                <br>
                                <h3>Delegating to styles with lower precedence</h3>
                                <p>It is possible for higher precedence styles to "delegate" to lower precedence styles using undefined values. Whereas setting a style property to null ensures the style is removed, setting it to undefined causes Angular to fall back to the next-highest precedence binding to that style.</p>
                                <p>For example, consider the following template:</p>
                                <code-example code="
                                    < comp-with-host-binding dirWithHostBinding></comp-with-host-binding>
                                "></code-example>

                                <p>Imagine that the dirWithHostBinding directive and the comp-with-host-binding component both have a [style.width] host binding. In that case, if dirWithHostBinding sets its binding to undefined, the width property falls back to the value of the comp-with-host-binding host binding. However, if dirWithHostBinding sets its binding to null, the width property will be removed entirely.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content8>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Injecting attribute values
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content8Content>
                            <ng-container #description_8>
                                <p>There are cases where you need to differentiate the behavior of a Component or Directive based on a static value set on the host element as an HTML attribute. For example, you might have a directive that needs to know the type of a < button> or < input> element.</p>
                                <p>The Attribute parameter decorator is great for passing the value of an HTML attribute to a component/directive constructor using dependency injection.</p>
                                <p class="note">The injected value captures the value of the specified HTML attribute at that moment. Future updates to the attribute value are not reflected in the injected value.</p>
                                <code-example code="
                                    import { Attribute, Component } from '@angular/core';

                                    @Component({
                                        selector: 'app-my-input-with-attribute-decorator',
                                        template: '<p>The type of the input is: { type }</p>'
                                    })
                                    export class MyInputWithAttributeDecoratorComponent {
                                        constructor(@Attribute('type') public type: string) { }
                                    }
                                "></code-example>

                                <code-example code="
                                    < app-my-input-with-attribute-decorator type='number'></app-my-input-with-attribute-decorator>
                                "></code-example>

                                <p>In the preceding example, the result of app.component.html is The type of the input is: number.</p>
                                <p>Another example is the RouterOutlet directive, which makes use of the Attribute decorator to retrieve the unique name on each outlet.</p>
                                <span class="note">
                                    <p>@ATTRIBUTE() VS @INPUT()</p>
                                    <p>Remember, use @Input() when you want to keep track of the attribute value and update the associated property. Use @Attribute() when you want to inject the value of an HTML attribute to a component or directive constructor.</p>
                                </span>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #eventBindingTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Event binding
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Event binding lets you listen for and respond to user actions such as keystrokes, mouse movements, clicks, and touches.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to events
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>To bind to an event you use the Angular event binding syntax. This syntax consists of a target event name within parentheses to the left of an equal sign, and a quoted template statement to the right. In the following example, the target event name is click and the template statement is onSave().</p>
                                <code-example code="
                                    < button (click)='onSave()'>Save</button>
                                "></code-example>
                                <p>The event binding listens for the button's click events and calls the component's onSave() method whenever a click occurs.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Binding to passive events
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Angular also supports passive event listeners. For example, use the following steps to make a scroll event passive.</p>
                                <ol>
                                    <li>
                                        <p>Create a file zone-flags.ts under src directory.</p>
                                    </li>
                                    <li>
                                        <p>Add the following line into this file.</p>
                                    
                                        <code-example code="
                                            (window as any)['__zone_symbol__PASSIVE_EVENTS'] = ['scroll'];
                                        "></code-example>
                                    </li>
                                    <li>
                                        <p>In the src/polyfills.ts file, before importing zone.js, import the newly created zone-flags.</p>
                                        <code-example code="
                                            import './zone-flags';
                                            import 'zone.js';  // Included with Angular CLI.
                                        "></code-example>
                                    </li>
                                </ol>
                                <p>After those steps, if you add event listeners for the scroll event, the listeners will be passive.</p>
                                
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Custom events with EventEmitter
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>Directives typically raise custom events with an Angular EventEmitter as follows.</p>
                                <ol>
                                    <li>The directive creates an EventEmitter and exposes it as a property.</li>
                                    <li>The directive then calls EventEmitter.emit(data) to emit an event, passing in message data, which can be anything.</li>
                                    <li>Parent directives listen for the event by binding to this property and accessing the data through the $event object.</li>
                                </ol>

                                <p>Consider an ItemDetailComponent that presents item information and responds to user actions. Although the ItemDetailComponent has a delete button, it doesn't contain the functionality to delete the hero. It can only raise an event reporting the user's delete request.</p>
                                <code-example code="
                                    < img src='{itemImageUrl}' [style.display]='displayNone'>
                                    < span [style.text-decoration]='lineThrough'>{' item.name '}
                                    </span>
                                    < button (click)='delete()'>Delete</button>
                                "></code-example>

                                <p>The component defines a deleteRequest property that returns an EventEmitter. When the user clicks Delete, the component invokes the delete() method, telling the EventEmitter to emit an Item object.</p>
                                <code-example code="
                                    // This component makes a request but it can't actually delete a hero.
                                    @Output() deleteRequest = new EventEmitter<Item>();
                                    
                                    delete() {
                                        this.deleteRequest.emit(this.item);
                                        this.displayNone = this.displayNone ? '' : 'none';
                                        this.lineThrough = this.lineThrough ? '' : 'line-through';
                                    }
                                "></code-example>

                                <p>The hosting parent component binds to the deleteRequest event of the ItemDetailComponent as follows.</p>
                                <code-example code="
                                    < app-item-detail (deleteRequest)='deleteItem($event)' [item]='currentItem'></app-item-detail>
                                "></code-example>

                                <p>When the deleteRequest event fires, Angular calls the parent component's deleteItem() method with the item.</p>
                                <br>
                                <h3>Determining an event target</h3>
                                <p>To determine an event target, Angular checks if the name of the target event matches an event property of a known directive. In the following example, Angular checks to see if myClick is an event on the custom ClickDirective.</p>
                                <code-example code="
                                    < h4>myClick is an event on the custom ClickDirective:</h4>
                                    < button (myClick)='clickMessage=$event' clickable>click with myClick</button>
                                    {clickMessage}
                                "></code-example>

                                <p>If the target event name, myClick fails to match an element event or an output property of ClickDirective, Angular reports an "unknown directive" error.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #twoWayBindingTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Two-way binding
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Two-way binding gives components in your application a way to share data. Use two-way binding to listen for events and update values simultaneously between parent and child components.</p>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Prerequisites
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>To get the most out of two-way binding, you should have a basic understanding of the following concepts:</p>
                                <ul>
                                    <li>Property binding</li>
                                    <li>Event binding</li>
                                    <li>Inputs and Outputs</li>
                                </ul>

                                <p>Two-way binding combines property binding with event binding:</p>
                                <ul>
                                    <li>Property binding sets a specific element property.</li>
                                    <li>Event binding listens for an element change event.</li>
                                </ul>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Adding two-way data binding
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Angular's two-way binding syntax is a combination of square brackets and parentheses, [()]. The [()] syntax combines the brackets of property binding, [], with the parentheses of event binding, (), as follows.</p>
                                <code-example code="
                                    < app-sizer [(size)]='fontSizePx'></app-sizer>
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                How two-way binding works
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>For two-way data binding to work, the @Output() property must use the pattern, inputChange, where input is the name of the @Input() property. For example, if the @Input() property is size, the @Output() property must be sizeChange.</p>
                                <p>The following sizerComponent has a size value property and a sizeChange event. The size property is an @Input(), so data can flow into the sizerComponent. The sizeChange event is an @Output(), which lets data flow out of the sizerComponent to the parent component.</p>
                                <p>Next, there are two methods, dec() to decrease the font size and inc() to increase the font size. These two methods use resize() to change the value of the size property within min/max value constraints, and to emit an event that conveys the new size value.</p>
                                <code-example code="
                                    export class SizerComponent {

                                        @Input()  size!: number | string;
                                        @Output() sizeChange = new EventEmitter<number>();
                                    
                                        dec() { this.resize(-1); }
                                        inc() { this.resize(+1); }
                                    
                                        resize(delta: number) {
                                            this.size = Math.min(40, Math.max(8, +this.size + delta));
                                            this.sizeChange.emit(this.size);
                                        }
                                    }
                                "></code-example>

                                <p>The sizerComponent template has two buttons that each bind the click event to the inc() and dec() methods. When the user clicks one of the buttons, the sizerComponent calls the corresponding method. Both methods, inc() and dec(), call the resize() method with a +1 or -1, which in turn raises the sizeChange event with the new size value.</p>
                                <code-example code="
                                    < div>
                                        < button (click)='dec()' title='smaller'>-</button>
                                        < button (click)='inc()' title='bigger'>+</button>
                                        < label [style.font-size.px]='size'>FontSize: {size}px</label>
                                    </div>
                                "></code-example>

                                <p>In the AppComponent template, fontSizePx is two-way bound to the SizerComponent.</p>
                                <code-example code="
                                    < app-sizer [(size)]='fontSizePx'></app-sizer>
                                    < div [style.font-size.px]='fontSizePx'>Resizable Text</div>
                                "></code-example>

                                <p>In the AppComponent, fontSizePx establishes the initial SizerComponent.size value by setting the value to 16.</p>
                                <code-example code="
                                    fontSizePx = 16;
                                "></code-example>

                                <p>Clicking the buttons updates the AppComponent.fontSizePx. The revised AppComponent.fontSizePx value updates the style binding, which makes the displayed text bigger or smaller.</p>
                                <p>The two-way binding syntax is shorthand for a combination of property binding and event binding. The SizerComponent binding as separate property binding and event binding is as follows.</p>
                                <code-example code="
                                    < app-sizer [size]='fontSizePx' (sizeChange)='fontSizePx=$event'></app-sizer>
                                "></code-example>

                                <p>The $event variable contains the data of the SizerComponent.sizeChange event. Angular assigns the $event value to the AppComponent.fontSizePx when the user clicks the buttons.</p>
                                <span class="note">
                                    <p>TWO-WAY BINDING IN FORMS</p>
                                    <p>Because no built-in HTML element follows the x value and xChange event pattern, two-way binding with form elements requires NgModel. For more information on how to use two-way binding in forms, see Angular NgModel.</p>
                                </span>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #templateReferenceVariableTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Template variables
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>Template variables help you use data from one part of a template in another part of the template. Use template variables to perform tasks such as respond to user input or finely tune your application's forms.</p>
                <p>A template variable can refer to the following:</p>
                <ul>
                    <li>a DOM element within a template</li>
                    <li>a directive</li>
                    <li>an element</li>
                    <li>TemplateRef</li>
                    <li>a web component</li>
                </ul>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Syntax
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content1Content>
                            <ng-container #description_1>
                                <p>In the template, you use the hash symbol, #, to declare a template variable. The following template variable, #phone, declares a phone variable on an < input> element.</p>
                                <code-example code="
                                    < input #phone placeholder='phone number' />
                                "></code-example>

                                <p>Refer to a template variable anywhere in the component's template. Here, a < button> further down the template refers to the phone variable.</p>
                                <code-example code="
                                    < input #phone placeholder='phone number' />

                                    <!-- lots of other elements -->
                                    
                                    <!-- phone refers to the input element; pass its `value` to an event handler -->
                                    < button (click)='callPhone(phone.value)'>Call</button>
                                "></code-example>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                How Angular assigns values to template variables
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content2Content>
                            <ng-container #description_2>
                                <p>Angular assigns a template variable a value based on where you declare the variable:</p>
                                <ul>
                                    <li>If you declare the variable on a component, the variable refers to the component instance.</li>
                                    <li>If you declare the variable on a standard HTML tag, the variable refers to the element.</li>
                                    <li>If you declare the variable on an < ng-template> element, the variable refers to a TemplateRef instance, which represents the template. For more information on < ng-template>, see How Angular uses the asterisk, *, syntax in Structural directives.</li>
                                    <li>If the variable specifies a name on the right-hand side, such as #var="ngModel", the variable refers to the directive or component on the element with a matching exportAs name.</li>
                                </ul>

                                <br>
                                <h3>Using NgForm with template variables</h3>
                                <p>In most cases, Angular sets the template variable's value to the element on which it occurs. In the previous example, phone refers to the phone number < input>. The button's click handler passes the < input> value to the component's callPhone() method.</p>
                                <p>The NgForm directive demonstrates getting a reference to a different value by reference a directive's exportAs name. In the following example, the template variable, itemForm, appears three times separated by HTML.</p>
                                <code-example code="
                                    < form #itemForm='ngForm' (ngSubmit)='onSubmit(itemForm)'>
                                        < label for='name'>Name <input class='form-control' name='name' ngModel required />
                                        </label>
                                        < button type='submit'>Submit</button>
                                    </form>
                                    
                                    < div [hidden]='!itemForm.form.valid'>
                                        <p>{ submitMessage }</p>
                                    </div>
                                "></code-example>

                                <p>Without the ngForm attribute value, the reference value of itemForm would be the HTMLFormElement, < form>. There is, however, a difference between a Component and a Directive in that Angular references a Component without specifying the attribute value, and a Directive does not change the implicit reference, or the element.</p>
                                <p>With NgForm, itemForm is a reference to the NgForm directive with the ability to track the value and validity of every control in the form.</p>
                                <p>Unlike the native < form> element, the NgForm directive has a form property. The NgForm form property lets you disable the submit button if the itemForm.form.valid is invalid.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Template variable scope
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content3Content>
                            <ng-container #description_3>
                                <p>Refer to a template variable anywhere within its surrounding template. Structural directives, such as *ngIf and *ngFor, or < ng-template> act as a template boundary. You cannot access template variables outside of these boundaries.</p>
                                <p class="note">Define a variable only once in the template so the runtime value remains predictable.</p>
                            </ng-container>

                            <ng-container #content3_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Accessing in a nested template
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                        
                                        <ng-container #content3Content_1>
                                            <ng-container #description_3_1>
                                                <p>An inner template can access template variables that the outer template defines.</p>
                                                <p>In the following example, changing the text in the < input> changes the value in the < span> because Angular immediately updates changes through the template variable, ref1.</p>
                                                <code-example code="
                                                    < input #ref1 type='text' [(ngModel)]='firstExample' />
                                                    < span *ngIf='true'>Value: { ref1.value }</span>
                                                "></code-example>

                                                <p>In this case, there is an implied < ng-template> around the < span> and the definition of the variable is outside of it. Accessing a template variable from the parent template works because the child template inherits the context from the parent template.</p>
                                                <p>Rewriting the preceding code in a more verbose form explicitly shows the < ng-template>.</p>
                                                <code-example code="
                                                    < input #ref1 type='text' [(ngModel)]='firstExample' />

                                                    <!-- New template -->
                                                    < ng-template [ngIf]='true'>
                                                    <!-- Because the context is inherited, the value is available to the new template -->
                                                    < span>Value: { ref1.value }</span>
                                                    </ng-template>
                                                "></code-example>

                                                <p>However, accessing a template variable from outside the parent template doesn't work.</p>
                                                <code-example code="
                                                    < input *ngIf='true' #ref2 type='text' [(ngModel)]='secondExample' />
                                                    < span>Value: { ref2?.value }</span> <!-- doesn't work -->
                                                "></code-example>

                                                <p>The verbose form shows that ref2 is outside the parent template.</p>
                                                <code-example code="
                                                    < ng-template [ngIf]='true'>
                                                        <!-- The reference is defined within a template -->
                                                        <input #ref2 type='text' [(ngModel)]='secondExample' />
                                                    </ng-template>
                                                    <!-- ref2 accessed from outside that template doesn't work -->
                                                    < span>Value: { ref2?.value }</span>
                                                "></code-example>

                                                <p>Consider the following example that uses *ngFor.</p>
                                                <code-example code="
                                                    < ng-container *ngFor='let i of [1,2]'>
                                                        < input #ref type='text' [value]='i' />
                                                    </ng-container>
                                                    { ref.value }
                                                "></code-example>

                                                <p>Here, ref.value doesn't work. The structural directive, *ngFor instantiates the template twice because *ngFor iterates over the two items in the array. It is impossible to define what the ref.value reference signifies.</p>
                                                <p>With structural directives, such as *ngFor or *ngIf, there is no way for Angular to know if a template is ever instantiated.</p>
                                                <p>As a result, Angular isn't able to access the value and returns an error.</p>
                                            </ng-container>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Accessing a template variable within < ng-template>
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                        
                                        <ng-container #content3Content_2>
                                            <ng-container #description_3_2>
                                                <p>When you declare the variable on an < ng-template>, the variable refers to a TemplateRef instance, which represents the template.</p>
                                                <code-example code="
                                                    < ng-template #ref3></ng-template>
                                                    < button (click)='log(ref3)'>Log type of #ref</button>
                                                "></code-example>

                                                <p>In this example, clicking the button calls the log() function, which outputs the value of #ref3 to the console. Because the #ref variable is on an < ng-template>, the value is TemplateRef.</p>
                                                <p>The following is the expanded browser console output of the TemplateRef() function with the name of TemplateRef.</p>
                                                <code-example code="
                                                    ▼ ƒ TemplateRef()
                                                    name: 'TemplateRef'
                                                    __proto__: Function
                                                "></code-example>
                                            </ng-container>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                Template input variable
                            </mat-panel-title>
                        </mat-expansion-panel-header>
        
                        <ng-container #content4Content>
                            <ng-container #description_4>
                                <p>A template input variable is a variable to reference within a single instance of the template. You declare a template input variable using the let keyword as in let hero.</p>
                                <p>There are several such variables in this example: hero, i, and odd.</p>
                                <code-example code="
                                    < ng-template #hero let-hero let-i='index' let-odd='isOdd'>
                                        < div [class]='{'odd-row': odd}'>{i}:{hero.name}</div>
                                    </ng-template>
                                "></code-example>

                                <p>The variable's scope is limited to a single instance of the repeated template. Use the same variable name again in the definition of other structural directives.</p>
                                <p>In contrast, you declare a template variable by prefixing the variable name with #, as in #var. A template variable refers to its attached element, component, or directive.</p>
                                <p>Template input variables and template variables names have their own namespaces. The template input variable hero in let hero is distinct from the template variable hero in #hero.</p>
                            </ng-container>
                        </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #svgTemplatesTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            SVG as templates
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #overviewContent>
            <ng-container #description>
                <p>You can use SVG files as templates in your Angular applications. When you use an SVG as the template, you are able to use directives and bindings just like with HTML templates. Use these features to dynamically generate interactive graphics.</p>
           
                <h3>SVG syntax example</h3>
                <p>The following example shows the syntax for using an SVG as a template.</p>
                <code-example code="
                    import { Component } from '@angular/core';

                    @Component({
                        selector: 'app-svg',
                        templateUrl: './svg.component.svg',
                        styleUrls: ['./svg.component.css']
                    })
                    export class SvgComponent {
                        fillColor = 'rgb(255, 0, 0)';
                        
                        changeColor() {
                            const r = Math.floor(Math.random() * 256);
                            const g = Math.floor(Math.random() * 256);
                            const b = Math.floor(Math.random() * 256);
                            this.fillColor = `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                "></code-example>

                <p>To see property and event binding in action, add the following code to your svg.component.svg file:</p>
                <code-example code="
                    < svg>
                        < g>
                        < rect x='0' y='0' width='100' height='100' [attr.fill]='fillColor' (click)='changeColor()' />
                        < text x='120' y='50'>click the rectangle to change the fill color</text>
                        </g>
                    </svg>
                "></code-example>

                <p>The example given uses a click() event binding and the property binding syntax ([attr.fill]="fillColor").</p>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>