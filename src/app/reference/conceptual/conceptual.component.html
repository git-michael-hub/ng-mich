<ng-container>
    <section>
        <h1>Conceptual</h1>
        <mat-accordion>
          <ng-container *ngTemplateOutlet="angularConceptsTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="workspaceTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="ngModulesTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="observableRxjsTemplate"></ng-container>
          <ng-container *ngTemplateOutlet="dependencyInjectionTemplate"></ng-container>
        </mat-accordion>
    </section>
</ng-container>

<ng-template #angularConceptsTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Angular Concepts
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #angularConceptsContent>
            <ng-container #description>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Basic Concepts
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content1Content>
                          <ng-container #description_1>
                              <p>Angular is a platform and framework for building single-page client applications using HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your applications.</p>
                              <p>The architecture of an Angular application relies on certain fundamental concepts. The basic building blocks of the Angular framework are Angular components that are organized into NgModules. NgModules collect related code into functional sets; an Angular application is defined by a set of NgModules. An application always has at least a root module that enables bootstrapping, and typically has many more feature modules.</p>
                              <ul>
                                  <li>Components define views, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.</li>
                                  <li>Components use services, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.</li>
                              </ul>
                              <p>Modules, components and services are classes that use decorators. These decorators mark their type and provide metadata that tells Angular how to use them.</p>
                              <ul>
                                  <li>The metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.</li>
                                  <li>The metadata for a service class provides the information Angular needs to make it available to components through dependency injection (DI).</li>
                              </ul>
                              <p>An application's components typically define many views, arranged hierarchically. Angular provides the Router service to help you define navigation paths among views. The router provides sophisticated in-browser navigational capabilities.</p>
                          </ng-container>

                            <ng-container #content1_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Modules
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content1_1_Inner>
                                            <p>Angular NgModules differ from and complement JavaScript (ES2015) modules. An NgModule declares a compilation context for a set of components that is dedicated to an application domain, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.</p>
                                            <p>Every Angular application has a root module, conventionally named AppModule, which provides the bootstrap mechanism that launches the application. An application typically contains many functional modules.</p>
                                            <p>Like JavaScript modules, NgModules can import functionality from other NgModules, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the Router NgModule.</p>
                                            <p>Organizing your code into distinct functional modules helps in managing development of complex applications, and in designing for reusability. In addition, this technique lets you take advantage of lazy-loading—that is, loading modules on demand—to minimize the amount of code that needs to be loaded at startup.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content1_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Components
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content1_2_Inner>
                                            <p>Every Angular application has at least one component, the root component that connects a component hierarchy with the page document object model (DOM). Each component defines a class that contains application data and logic, and is associated with an HTML template that defines a view to be displayed in a target environment.</p>
                                            <p>The @Component() decorator identifies the class immediately below it as a component, and provides the template and related component-specific metadata.</p>
                                            <p class="note">
                                                Decorators are functions that modify JavaScript classes. Angular defines a number of decorators that attach specific kinds of metadata to classes, so that the system knows what those classes mean and how they should work.
                                            </p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content1_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Templates, directives, and data binding
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content1_3_Inner>
                                            <p>A template combines HTML with Angular markup that can modify HTML elements before they are displayed. Template directives provide program logic, and binding markup connects your application data and the DOM. There are two types of data binding:</p>
                                            <ul>
                                                <li>Event binding lets your application respond to user input in the target environment by updating your application data.</li>
                                                <li>Property binding lets you interpolate values that are computed from your application data into the HTML.</li>
                                            </ul>
                                            <p>Before a view is displayed, Angular evaluates the directives and resolves the binding syntax in the template to modify the HTML elements and the DOM, according to your program data and logic. Angular supports two-way data binding, meaning that changes in the DOM, such as user choices, are also reflected in your program data.</p>
                                            <p>Your templates can use pipes to improve the user experience by transforming values for display. For example, use pipes to display dates and currency values that are appropriate for a user's locale. Angular provides predefined pipes for common transformations, and you can also define your own pipes.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content1_4>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Services and dependency injection
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content1_4_Inner>
                                            <p>For data or logic that isn't associated with a specific view, and that you want to share across components, you create a service class. A service class definition is immediately preceded by the @Injectable() decorator. The decorator provides the metadata that allows other providers to be injected as dependencies into your class.</p>
                                            <p>Dependency injection (DI) lets you keep your component classes lean and efficient. They don't fetch data from the server, validate user input, or log directly to the console; they delegate such tasks to services.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content1_5>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Routing
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content1_5_Inner>
                                            <p>The Angular Router NgModule provides a service that lets you define a navigation path among the different application states and view hierarchies in your application. It is modeled on the familiar browser navigation conventions:</p>
                                            <ul>
                                                <li>Enter a URL in the address bar and the browser navigates to a corresponding page.</li>
                                                <li>Click links on the page and the browser navigates to a new page.</li>
                                                <li>Click the browser's back and forward buttons and the browser navigates backward and forward through the history of pages you've seen.</li>
                                            </ul>
                                            <p>The router maps URL-like paths to views instead of pages. When a user performs an action, such as clicking a link, that would load a new page in the browser, the router intercepts the browser's behavior, and shows or hides view hierarchies.</p>
                                            <p>If the router determines that the current application state requires particular functionality, and the module that defines it hasn't been loaded, the router can lazy-load the module on demand.</p>
                                            <p>The router interprets a link URL according to your application's view navigation rules and data state. You can navigate to new views when the user clicks a button or selects from a drop box, or in response to some other stimulus from any source. The router logs activity in the browser's history, so the back and forward buttons work as well.</p>
                                            <p>To define navigation rules, you associate navigation paths with your components. A path uses a URL-like syntax that integrates your program data, in much the same way that template syntax integrates your views with your program data. You can then apply program logic to choose which views to show or to hide, in response to user input and your own access rules.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Introduction to modules
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content2Content>
                          <ng-container #description_2>
                              <p>Angular applications are modular and Angular has its own modularity system called NgModules. NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules.</p>
                              <p>Every Angular application has at least one NgModule class, the root module, which is conventionally named AppModule and resides in a file named app.module.ts. You launch your application by bootstrapping the root NgModule.</p>
                              <p>While a small application might have only one NgModule, most applications have many more feature modules. The root NgModule for an application is so named because it can include child NgModules in a hierarchy of any depth.</p>
                          </ng-container>

                            <ng-container #content2_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                NgModule metadata
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content2_1_Inner>
                                            <p>An NgModule is defined by a class decorated with @NgModule(). The @NgModule() decorator is a function that takes a single metadata object, whose properties describe the module. The most important properties are as follows.</p>
                                            <ul>
                                                <li>declarations: The components, directives, and pipes that belong to this NgModule.</li>
                                                <li>exports: The subset of declarations that should be visible and usable in the component templates of other NgModules.</li>
                                                <li>imports: Other modules whose exported classes are needed by component templates declared in this NgModule.</li>
                                                <li>providers: Creators of services that this NgModule contributes to the global collection of services; they become accessible in all parts of the application. (You can also specify providers at the component level.)</li>
                                                <li>bootstrap: The main application view, called the root component, which hosts all other application views. Only the root NgModule should set the bootstrap property.</li>
                                            </ul>
                                            <p>Here's a simple root NgModule definition.</p>
                                            <code-example code="
                                            import { NgModule } from '@angular/core';
                                            import { BrowserModule } from '@angular/platform-browser';
                                            @NgModule({
                                              imports:      [ BrowserModule ],
                                              providers:    [ Logger ],
                                              declarations: [ AppComponent ],
                                              exports:      [ AppComponent ],
                                              bootstrap:    [ AppComponent ]
                                            })
                                            export class AppModule { }
                                            "></code-example>
                                            <p>AppComponent is included in the exports list here for illustration; it isn't actually necessary in this example. A root NgModule has no reason to export anything because other modules don't need to import the root NgModule.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content2_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                NgModules and components
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content2_2_Inner>
                                            <p>NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context.</p>
                                            <p>A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries.</p>
                                            <p>When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth.</p>
                                            <p class="note">
                                                Note: The hierarchical structure of views is a key factor in the way Angular detects and responds to changes in the DOM and application data.
                                            </p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content2_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                NgModules and JavaScript modules
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content2_3_Inner>
                                            <p>The NgModule system is different from and unrelated to the JavaScript (ES2015) module system for managing collections of JavaScript objects. These are complementary module systems that you can use together to write your applications.</p>
                                            <p>In JavaScript each file is a module and all objects defined in the file belong to that module. The module declares some objects to be public by marking them with the export key word. Other JavaScript modules use import statements to access public objects from other modules.</p>
                                            <code-example code="
                                            import { NgModule } from '@angular/core';
                                            import { AppComponent } from './app.component';
                                            "></code-example>

                                            <code-example code="
                                            export class AppModule { }
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content2_4>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Angular libraries
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content2_4_Inner>
                                            <p>Angular loads as a collection of JavaScript modules. You can think of them as library modules. Each Angular library name begins with the @angular prefix. Install them with the node package manager npm and import parts of them with JavaScript import statements.</p>
                                            <p>For example, import Angular's Component decorator from the @angular/core library like this.</p>
                                            <code-example code="
                                            import { Component } from '@angular/core';
                                            "></code-example>
                                            <p>You also import NgModules from Angular libraries using JavaScript import statements. For example, the following code imports the BrowserModule NgModule from the platform-browser library.</p>
                                            <code-example code="
                                            import { BrowserModule } from '@angular/platform-browser';
                                            "></code-example>
                                            <p>In the example of the simple root module above, the application module needs material from within BrowserModule. To access that material, add it to the @NgModule metadata imports like this.</p>
                                            <code-example code="
                                            imports:      [ BrowserModule ],
                                            "></code-example>
                                            <p>In this way you're using the Angular and JavaScript module systems together. Although it's easy to confuse the two systems, which share the common vocabulary of "imports" and "exports", you will become familiar with the different contexts in which they are used.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Introduction to components and templates
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content3Content>
                          <ng-container #description_3>
                             <p>A component controls a patch of screen called a view. For example, individual components define and control each of the following views from the Tour of Heroes tutorial:</p>
                             <ul>
                                 <li>The application root with the navigation links.</li>
                                 <li>The list of heroes.</li>
                                 <li>The hero editor.</li>
                             </ul>
                             <p>You define a component's application logic—what it does to support the view—inside a class. The class interacts with the view through an API of properties and methods.</p>
                             <p>For example, HeroListComponent has a heroes property that holds an array of heroes. Its selectHero() method sets a selectedHero property when the user clicks to choose a hero from that list. The component acquires the heroes from a service, which is a TypeScript parameter property on the constructor. The service is provided to the component through the dependency injection system.</p>
                             <code-example code="
                             export class HeroListComponent implements OnInit {
                                heroes: Hero[] = [];
                                selectedHero: Hero | undefined;
                              
                                constructor(private service: HeroService) { }
                              
                                ngOnInit() {
                                  this.heroes = this.service.getHeroes();
                                }
                              
                                selectHero(hero: Hero) { this.selectedHero = hero; }
                              }
                             "></code-example>
                             <p>Angular creates, updates, and destroys components as the user moves through the application. Your application can take action at each moment in this lifecycle through optional lifecycle hooks, like ngOnInit().</p>
                          </ng-container>

                            <ng-container #content3_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Component metadata
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_1_Inner>
                                            <p>The @Component decorator identifies the class immediately below it as a component class, and specifies its metadata. In the example code below, you can see that HeroListComponent is just a class, with no special Angular notation or syntax at all. It's not a component until you mark it as one with the @Component decorator.</p>
                                            <p>The metadata for a component tells Angular where to get the major building blocks that it needs to create and present the component and its view. In particular, it associates a template with the component, either directly with inline code, or by reference. Together, the component and its template describe a view.</p>
                                            <p>In addition to containing or pointing to the template, the @Component metadata configures, for example, how the component can be referenced in HTML and what services it requires.</p>
                                            <p>Here's an example of basic metadata for HeroListComponent.</p>
                                            <code-example code="
                                            @Component({
                                                selector:    'app-hero-list',
                                                templateUrl: './hero-list.component.html',
                                                providers:  [ HeroService ]
                                              })
                                              export class HeroListComponent implements OnInit {
                                                /* . . . */
                                              }
                                            "></code-example>
                                            <p>This example shows some of the most useful @Component configuration options:</p>
                                            <ul>
                                                <li>selector: A CSS selector that tells Angular to create and insert an instance of this component wherever it finds the corresponding tag in template HTML. For example, if an application's HTML contains  app-hero-list> / app-hero-list>, then Angular inserts an instance of the HeroListComponent view between those tags.</li>
                                                <li>templateUrl: The module-relative address of this component's HTML template. Alternatively, you can provide the HTML template inline, as the value of the template property. This template defines the component's host view.</li>
                                                <li>providers: An array of providers for services that the component requires. In the example, this tells Angular how to provide the HeroService instance that the component's constructor uses to get the list of heroes to display.</li>
                                            </ul>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Templates and views
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_2_Inner>
                                            <p>You define a component's view with its companion template. A template is a form of HTML that tells Angular how to render the component.</p>
                                            <p>Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components.</p>
                                            <p>A view hierarchy can include views from components in the same NgModule, but it also can (and often does) include views from components that are defined in different NgModules.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Template syntax
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_3_Inner>
                                            <p>A template looks like regular HTML, except that it also contains Angular template syntax, which alters the HTML based on your application's logic and the state of application and DOM data. Your template can use data binding to coordinate the application and DOM data, pipes to transform data before it is displayed, and directives to apply application logic to what gets displayed.</p>
                                            <p>For example, here is a template for the Tutorial's HeroListComponent.</p>
                                            <code-example code="
                                            <h2>Hero List</h2>

                                            <p><i>Select a hero from the list to see details.</i></p>
                                            <ul>
                                              <li *ngFor='let hero of heroes' (click)='selectHero(hero)'>
                                                [[hero.name]]
                                              </li>
                                            </ul>
                                            
                                            <app-hero-detail *ngIf='selectedHero' [hero]='selectedHero'></app-hero-detail>
                                            "></code-example>
                                            <p>This template uses typical HTML elements like < h2> and < p>, and also includes Angular template-syntax elements, *ngFor, {{'{{hero.name}}'}}, (click), [hero], and < app-hero-detail>. The template-syntax elements tell Angular how to render the HTML to the screen, using program logic and data.</p>
                                            <ul>
                                                <li>The *ngFor directive tells Angular to iterate over a list.</li>
                                                <li>[[hero.name]], (click), and [hero] bind program data to and from the DOM, responding to user input. See more about data binding below.</li>
                                                <li>The < app-hero-detail> tag in the example is an element that represents a new component, HeroDetailComponent. HeroDetailComponent (code not shown) defines the hero-detail child view of HeroListComponent. Notice how custom components like this mix seamlessly with native HTML in the same layouts.</li>
                                            </ul>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_4>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Data binding
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_4_Inner>
                                            <p>Without a framework, you would be responsible for pushing data values into the HTML controls and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.</p>
                                            <p>Angular supports two-way data binding, a mechanism for coordinating the parts of a template with the parts of a component. Add binding markup to the template HTML to tell Angular how to connect both sides.</p>
                                            <p>The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both.</p>
                                            <p>This example from the HeroListComponent template uses three of these forms.</p>
                                            <code-example code="
                                            <li>[[hero.name]]</li>
                                            <app-hero-detail [hero]='selectedHero'></app-hero-detail>
                                            <li (click)='selectHero(hero)'></li>
                                            "></code-example>
                                            <ul>
                                                <li>The [[hero.name]] interpolation displays the component's hero.name property value within the < li> element.</li>
                                                <li>The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent.</li>
                                                <li>The (click) event binding calls the component's selectHero method when the user clicks a hero's name.</li>
                                            </ul>
                                            <p>Two-way data binding (used mainly in template-driven forms) combines property and event binding in a single notation. Here's an example from the HeroDetailComponent template that uses two-way data binding with the ngModel directive.</p>
                                            <code-example code="
                                            <input type='text' id='hero-name' [(ngModel)]='hero.name'>
                                            "></code-example>

                                            <p>In two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.</p>
                                            <p>Angular processes all data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components.</p>
                                            <p>Data binding plays an important role in communication between a template and its component, and is also important for communication between parent and child components.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_5>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Pipes
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_5_Inner>
                                            <p>Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view.</p>
                                            <p>Angular defines various pipes, such as the date pipe and currency pipe; for a complete list, see the Pipes API list. You can also define new pipes.</p>
                                            <p>To specify a value transformation in an HTML template, use the pipe operator (|).</p>
                                            <code-example code="
                                            [[interpolated_value | pipe_name]]
                                            "></code-example>

                                            <p>You can chain pipes, sending the output of one pipe function to be transformed by another pipe function. A pipe can also take arguments that control how it performs its transformation. For example, you can pass the desired format to the date pipe.</p>
                                            <code-example code="
                                            <!-- Default format: output 'Jun 15, 2015'-->
                                            <p>Today is [[today | date]]</p>
                                           
                                           <!-- fullDate format: output 'Monday, June 15, 2015'-->
                                           <p>The date is [[today | date:'fullDate']]</p>
                                           
                                            <!-- shortTime format: output '9:43 AM'-->
                                            <p>The time is [[today | date:'shortTime']]</p>
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content3_6>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Directives
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content3_6_Inner>
                                            <p>Angular templates are dynamic. When Angular renders them, it transforms the DOM according to the instructions given by directives. A directive is a class with a @Directive() decorator.</p>
                                            <p>A component is technically a directive. However, components are so distinctive and central to Angular applications that Angular defines the @Component() decorator, which extends the @Directive() decorator with template-oriented features.</p>
                                            <p>In addition to components, there are two other kinds of directives: structural and attribute. Angular defines a number of directives of both kinds, and you can define your own using the @Directive() decorator.</p>
                                            <p>Just as for components, the metadata for a directive associates the decorated class with a selector element that you use to insert it into HTML. In templates, directives typically appear within an element tag as attributes, either by name or as the target of an assignment or a binding.</p>

                                            <br>
                                            <h3>Structural directives</h3>
                                            <p>Structural directives alter layout by adding, removing, and replacing elements in the DOM. The example template uses two built-in structural directives to add application logic to how the view is rendered.</p>
                                            <code-example code="
                                            <li *ngFor='let hero of heroes'></li>
                                            <app-hero-detail *ngIf='selectedHero'></app-hero-detail>
                                            "></code-example>

                                            <ul>
                                                <li>*ngFor is an iterative; it tells Angular to stamp out one < li> per hero in the heroes list.</li>
                                                <li>*ngIf is a conditional; it includes the HeroDetail component only if a selected hero exists.</li>
                                            </ul>

                                            <br>
                                            <h3>Attribute directives</h3>
                                            <p>Attribute directives alter the appearance or behavior of an existing element. In templates they look like regular HTML attributes, hence the name.</p>
                                            <p>The ngModel directive, which implements two-way data binding, is an example of an attribute directive. ngModel modifies the behavior of an existing element (typically < input>) by setting its display value property and responding to change events.</p>
                                            <code-example code="
                                            <input type='text' id='hero-name' [(ngModel)]='hero.name'>
                                            "></code-example>
                                            <p>Angular has more pre-defined directives that either alter the layout structure (for example, ngSwitch) or modify aspects of DOM elements and components (for example, ngStyle and ngClass).</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Introduction to services and dependency injection
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content4Content>
                          <ng-container #description_4>
                              <p>Service is a broad category encompassing any value, function, or feature that an application needs. A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.</p>
                              <p>Angular distinguishes components from services to increase modularity and reusability. By separating a component's view-related functionality from other kinds of processing, you can make your component classes lean and efficient.</p>
                              <p>Ideally, a component's job is to enable the user experience and nothing more. A component should present properties and methods for data binding, in order to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model).</p>
                              <p>A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console. By defining such processing tasks in an injectable service class, you make those tasks available to any component. You can also make your application more adaptable by injecting different providers of the same kind of service, as appropriate in different circumstances.</p>
                              <p>Angular doesn't enforce these principles. Angular does help you follow these principles by making it easy to factor your application logic into services and make those services available to components through dependency injection.</p>
                          </ng-container>

                            <ng-container #content4_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Service examples
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content4_1_Inner>
                                            <p>Here's an example of a service class that logs to the browser console.</p>
                                            <code-example code="
                                            export class Logger {
                                                log(msg: any)   { console.log(msg); }
                                                error(msg: any) { console.error(msg); }
                                                warn(msg: any)  { console.warn(msg); }
                                              }
                                            "></code-example>
                                            <p>Services can depend on other services. For example, here's a HeroService that depends on the Logger service, and also uses BackendService to get heroes. That service in turn might depend on the HttpClient service to fetch heroes asynchronously from a server.</p>
                                            <code-example code="
                                            export class HeroService {
                                                private heroes: Hero[] = [];
                                              
                                                constructor(
                                                  private backend: BackendService,
                                                  private logger: Logger) { }
                                              
                                                getHeroes() {
                                                  this.backend.getAll(Hero).then( (heroes: Hero[]) => {
                                                    this.logger.log(`Fetched ${heroes.length} heroes.`);
                                                    this.heroes.push(...heroes); // fill cache
                                                  });
                                                  return this.heroes;
                                                }
                                              }
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content4_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Dependency injection (DI)
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content4_2_Inner>
                                            <p>DI is wired into the Angular framework and used everywhere to provide new components with the services or other things they need. Components consume services; that is, you can inject a service into a component, giving the component access to that service class.</p>
                                            <p>To define a class as a service in Angular, use the @Injectable() decorator to provide the metadata that allows Angular to inject it into a component as a dependency. Similarly, use the @Injectable() decorator to indicate that a component or other class (such as another service, a pipe, or an NgModule) has a dependency.</p>
                                            <ul>
                                                <li>The injector is the main mechanism. Angular creates an application-wide injector for you during the bootstrap process, and additional injectors as needed. You don't have to create injectors.</li>
                                                <li>An injector creates dependencies, and maintains a container of dependency instances that it reuses if possible.</li>
                                                <li>A provider is an object that tells an injector how to obtain or create a dependency.</li>
                                            </ul>
                                            <p>For any dependency that you need in your app, you must register a provider with the application's injector, so that the injector can use the provider to create new instances. For a service, the provider is typically the service class itself.</p>
                                            <p class="note">
                                                A dependency doesn't have to be a service—it could be a function, for example, or a value.
                                            </p>
                                            <p>When Angular creates a new instance of a component class, it determines which services or other dependencies that component needs by looking at the constructor parameter types. For example, the constructor of HeroListComponent needs HeroService.</p>
                                            <code-example code="
                                            constructor(private service: HeroService) { }
                                            "></code-example>

                                            <p>When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</p>
                                            <p>When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content4_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Providing services
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content4_3_Inner>
                                            <p>You must register at least one provider of any service you are going to use. The provider can be part of the service's own metadata, making that service available everywhere, or you can register providers with specific modules or components. You register providers in the metadata of the service (in the @Injectable() decorator), or in the @NgModule() or @Component() metadata</p>
                                            <ul>
                                                <li>
                                                    <p>By default, the Angular CLI command ng generate service registers a provider with the root injector for your service by including provider metadata in the @Injectable() decorator. The tutorial uses this method to register the provider of HeroService class definition.</p>
                                                    <code-example code="
                                                    @Injectable({
                                                        providedIn: 'root',
                                                       })
                                                    "></code-example>
                                                    <p>When you provide the service at the root level, Angular creates a single, shared instance of HeroService and injects it into any class that asks for it. Registering the provider in the @Injectable() metadata also allows Angular to optimize an app by removing the service from the compiled application if it isn't used, a process known as tree-shaking.</p>
                                                </li>
                                                <li>
                                                    <p>When you register a provider with a specific NgModule, the same instance of a service is available to all components in that NgModule. To register at this level, use the providers property of the @NgModule() decorator.</p>
                                                    <code-example code="
                                                    @NgModule({
                                                        providers: [
                                                        BackendService,
                                                        Logger
                                                       ],
                                                       ...
                                                      })
                                                    "></code-example>
                                                </li>
                                                <li>
                                                    <p>When you register a provider at the component level, you get a new instance of the service with each new instance of that component. At the component level, register a service provider in the providers property of the @Component() metadata.</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector:    'app-hero-list',
                                                        templateUrl: './hero-list.component.html',
                                                        providers:  [ HeroService ]
                                                      })
                                                    "></code-example>
                                                </li>
                                            </ul>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Binding syntax
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content5Content>
                          <ng-container #description_5>
                              <p>Data binding automatically keeps your page up-to-date based on your application's state. You use data binding to specify things such as the source of an image, the state of a button, or data for a particular user.</p>
                          </ng-container>

                            <ng-container #content5_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Data binding and HTML
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_1_Inner>
                                            <p>Developers can customize HTML by specifying attributes with string values. In the following example, class, src, and disabled modify the < div>, < img>, and < button> elements respectively.</p>
                                            <code-example code="
                                            <div class='special'>Plain old HTML</div>
                                            <img src='images/item.png'>
                                            <button disabled>Save</button>
                                            "></code-example>
                                            <p>Use data binding to control things like the state of a button:</p>
                                            <code-example code="
                                            <!-- Bind button disabled state to `isUnchanged` property -->
                                            <button [disabled]='isUnchanged'>Save</button>
                                            "></code-example>
                                            <p>Notice that the binding is to the disabled property of the button's DOM element, not the attribute. Data binding works with properties of DOM elements, components, and directives, not HTML attributes.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content5_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                HTML attributes and DOM properties
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_2_Inner>
                                            <p>Angular binding distinguishes between HTML attributes and DOM properties.</p>
                                            <p>Attributes initialize DOM properties and you can configure them to modify an element's behavior. Properties are features of DOM nodes.</p>
                                            <ul>
                                                <li>A few HTML attributes have 1:1 mapping to properties; for example, id.</li>
                                                <li>Some HTML attributes don't have corresponding properties; for example, aria-*.</li>
                                                <li>Some DOM properties don't have corresponding attributes; for example, textContent.</li>
                                            </ul>

                                            <p class="note">Remember that HTML attributes and DOM properties are different things, even when they have the same name.</p>
                                            <p>In Angular, the only role of HTML attributes is to initialize element and directive state.</p>
                                            <p>When you write a data binding, you're dealing exclusively with the DOM properties and events of the target object.</p>

                                            <h3>Example 1: an < input></h3>
                                            <p>When the browser renders < input type="text" value="Sarah">, it creates a corresponding DOM node with a value property and initializes that value to "Sarah".</p>
                                            <code-example code="
                                            <input type='text' value='Sarah'>
                                            "></code-example>

                                            <p>When the user enters Sally into the < input>, the DOM element value property becomes Sally. However, if you look at the HTML attribute value using input.getAttribute('value'), you can see that the attribute remains unchanged—it returns "Sarah".</p>
                                            <p>The HTML attribute value specifies the initial value; the DOM value property is the current value.</p>

                                            <br>
                                            <h3>Example 2: a disabled button</h3>
                                            <p>A button's disabled property is false by default so the button is enabled.</p>
                                            <p>When you add the disabled attribute, you are initializing the button's disabled property to true which disables the button.</p>
                                            <code-example code="
                                            <button disabled>Test Button</button>
                                            "></code-example>

                                            <p>Adding and removing the disabled attribute disables and enables the button. However, the value of the attribute is irrelevant, which is why you cannot enable a button by writing < button disabled="false">Still Disabled /button>.</p>
                                            <p>To control the state of the button, set the disabled property instead.</p>

                                            <br>
                                            <h3>Property and attribute comparison</h3>
                                            <p>Though you could technically set the [attr.disabled] attribute binding, the values are different in that the property binding must be a boolean value, while its corresponding attribute binding relies on whether the value is null or not. Consider the following:</p>
                                            <code-example code="
                                            <input [disabled]='condition ? true : false'>
                                            <input [attr.disabled]='condition ? 'disabled' : null'>
                                            "></code-example>

                                            <p>The first line, which uses the disabled property, uses a boolean value. The second line, which uses the disabled attribute checks for null.</p>
                                            <p>Generally, use property binding over attribute binding as a boolean value is easy to read, the syntax is shorter, and a property is more performant.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content5_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Types of data binding
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_3_Inner>
                                            <p>Angular provides three categories of data binding according to the direction of data flow:</p>
                                            <ul>
                                                <li>From the source to view</li>
                                                <li>From view to source</li>
                                                <li>In a two way sequence of view to source to view</li>
                                            </ul>

                                            <table>
                                                <thead>
                                                    <tr>
                                                        <td>Type</td>
                                                        <td>Syntax</td>
                                                        <td>Category</td>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>Interpolation
                                                            Property
                                                            Attribute
                                                            Class
                                                            Style
                                                        </td>
                                                        <td>
                                                            <code-example code="
                                                            [[expression]]
                                                            [target]='expression'
                                                            bind-target='expression'
                                                            "></code-example>
                                                        </td>
                                                        <td>One-way
                                                            from data source
                                                            to view target
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Event</td>
                                                        <td>
                                                            <code-example code="
                                                            (target)='statement'
                                                            on-target='statement'
                                                            "></code-example>
                                                        </td>
                                                        <td>
                                                            One-way from view target to data source
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Two-way</td>
                                                        <td>
                                                            <code-example code="
                                                            [(target)]='expression'
                                                            bindon-target='expression'
                                                            "></code-example>
                                                        </td>
                                                        <td>
                                                            Two-way
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>

                                            <p>Binding types other than interpolation have a target name to the left of the equal sign. The target of a binding is a property or event, which you surround with square brackets, [], parentheses, (), or both, [()].</p>
                                            <p>The binding punctuation of [], (), [()], and the prefix specify the direction of data flow.</p>
                                            <ul>
                                                <li>Use [] to bind from source to view.</li>
                                                <li>Use () to bind from view to source.</li>
                                                <li>Use [()] to bind in a two way sequence of view to source to view.</li>
                                            </ul>

                                            <p>Place the expression or statement to the right of the equal sign within double quotes, "". For more information see Interpolation and Template statements.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content5_4>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Binding types and targets
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content5_4_Inner>
                                            <p>The target of a data binding can be a property, an event, or an attribute name. Every public member of a source directive is automatically available for binding in a template expression or statement. The following table summarizes the targets for the different binding types.</p>
                                            <table>
                                                <thead>
                                                    <tr>
                                                        <td>Type</td>
                                                        <td>Target</td>
                                                        <td>Examples</td>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>Property</td>
                                                        <td>Element property
                                                            Component property
                                                            Directive property
                                                        </td>
                                                        <td>
                                                            <p>src, hero, and ngClass in the following:</p>
                                                            <code-example code="
                                                            <img [src]='heroImageUrl'>
                                                            <app-hero-detail [hero]='currentHero'></app-hero-detail>
                                                            <div [ngClass]='{'special': isSpecial}'></div>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Event</td>
                                                        <td>Element event
                                                            Component event
                                                            Directive event</td>
                                                        <td>
                                                            <p>click, deleteRequest, and myClick in the following:</p>
                                                            <code-example code="
                                                            <button (click)='onSave()'>Save</button>
                                                            <app-hero-detail (deleteRequest)='deleteHero()'></app-hero-detail>
                                                            <div (myClick)='clicked=$event' clickable>click me</div>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Two-way</td>
                                                        <td>Event and property</td>
                                                        <td>
                                                            <code-example code="
                                                            <input [(ngModel)]='name'>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Attribute</td>
                                                        <td>Attribute (the exception)</td>
                                                        <td>
                                                            <code-example code="
                                                            <button [attr.aria-label]='help'>help</button>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Class</td>
                                                        <td>class property</td>
                                                        <td>
                                                            <code-example code="
                                                            <div [class.special]='isSpecial'>Special</div>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Style</td>
                                                        <td>style property</td>
                                                        <td>
                                                            <code-example code="
                                                            <button [style.color]='isSpecial ? 'red' : 'green''>
                                                            "></code-example>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content6>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            How event binding works
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content6Content>
                          <ng-container #description_6>
                              <p>In an event binding, Angular configures an event handler for the target event. You can use event binding with your own custom events.</p>
                              <p>When the component or directive raises the event, the handler executes the template statement. The template statement performs an action in response to the event.</p>

                              <br>
                              <h3>Handling events</h3>
                              <p>A common way to handle events is to pass the event object, $event, to the method handling the event. The $event object often contains information the method needs, such as a user's name or an image URL.</p>
                              <p>The target event determines the shape of the $event object. If the target event is a native DOM element event, then $event is a DOM event object, with properties such as target and target.value.</p>
                              <p>In the following example the code sets the < input> value property by binding to the name property.</p>
                              <code-example code="
                              <input [value]='currentItem.name'
                              (input)='currentItem.name=getValue($event)'>
                              "></code-example>

                              <p>With this example, the following actions occur:</p>
                              <ul>
                                  <li>The code binds to the input event of the < input> element, which allows the code to listen for changes.</li>
                                  <li>When the user makes changes, the component raises the input event.</li>
                                  <li>The binding executes the statement within a context that includes the DOM event object, $event.</li>
                                  <li>Angular retrieves the changed text by calling getValue($event.target) and updates the name property.</li>
                              </ul>

                              <p>If the event belongs to a directive or component, $event has the shape that the directive or component produces.</p>
                              <span class="note">
                                  <p>The type of $event.target is only EventTarget in the template. In the getValue() method, the target is cast to an HTMLInputElement to allow type-safe access to its value property.</p>
                                  <p>
                                      <code-example code="
                                      getValue(event: Event): string {
                                        return (event.target as HTMLInputElement).value;
                                      }
                                      "></code-example>
                                  </p>
                              </span>
                          </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content7>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Template variables
                          </mat-panel-title>
                      </mat-expansion-panel-header>
      
                      <ng-container #content7Content>
                          <ng-container #description_7>
                              <p>Template variables help you use data from one part of a template in another part of the template. Use template variables to perform tasks such as respond to user input or finely tune your application's forms.</p>
                              <p>A template variable can refer to the following:</p>
                              <ul>
                                  <li>a DOM element within a template</li>
                                  <li>a directive</li>
                                  <li>an element</li>
                                  <li>TemplateRef</li>
                                  <li>a web component</li>
                              </ul>
                          </ng-container>

                            <ng-container #content7_1>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Syntax
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content7_1_Inner>
                                            <p>In the template, you use the hash symbol, #, to declare a template variable. The following template variable, #phone, declares a phone variable on an < input> element.</p>
                                            <code-example code="
                                            <input #phone placeholder='phone number' />
                                            "></code-example>

                                            <p>Refer to a template variable anywhere in the component's template. Here, a < button> further down the template refers to the phone variable.</p>
                                            <code-example code="
                                            <input #phone placeholder='phone number' />

                                            <!-- lots of other elements -->
                                            
                                            <!-- phone refers to the input element; pass its `value` to an event handler -->
                                            <button (click)='callPhone(phone.value)'>Call</button>
                                            "></code-example>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content7_2>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                How Angular assigns values to template variables
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content7_2_Inner>
                                            <p>Angular assigns a template variable a value based on where you declare the variable:</p>
                                            <ul>
                                                <li>If you declare the variable on a component, the variable refers to the component instance.</li>
                                                <li>If you declare the variable on a standard HTML tag, the variable refers to the element.</li>
                                                <li>If you declare the variable on an < ng-template> element, the variable refers to a TemplateRef instance, which represents the template. For more information on < ng-template>, see How Angular uses the asterisk, *, syntax in Structural directives.</li>
                                                <li>If the variable specifies a name on the right-hand side, such as #var="ngModel", the variable refers to the directive or component on the element with a matching exportAs name.</li>
                                            </ul>

                                            <br>
                                            <h3>Using NgForm with template variables</h3>
                                            <p>In most cases, Angular sets the template variable's value to the element on which it occurs. In the previous example, phone refers to the phone number < input>. The button's click handler passes the < input> value to the component's callPhone() method.</p>
                                            <p>The NgForm directive demonstrates getting a reference to a different value by reference a directive's exportAs name. In the following example, the template variable, itemForm, appears three times separated by HTML.</p>
                                            <code-example code="
                                            <form #itemForm='ngForm' (ngSubmit)='onSubmit(itemForm)'>
                                                <label for='name'>Name</label>
                                                <input type='text' id='name' class='form-control' name='name' ngModel required />
                                                <button type='submit'>Submit</button>
                                              </form>
                                              
                                              <div [hidden]='!itemForm.form.valid'>
                                                <p>[[ submitMessage ]]</p>
                                              </div>
                                            "></code-example>

                                            <p>Without the ngForm attribute value, the reference value of itemForm would be the HTMLFormElement, < form>. There is, however, a difference between a Component and a Directive in that Angular references a Component without specifying the attribute value, and a Directive does not change the implicit reference, or the element.</p>
                                            <p>With NgForm, itemForm is a reference to the NgForm directive with the ability to track the value and validity of every control in the form.</p>
                                            <p>Unlike the native < form> element, the NgForm directive has a form property. The NgForm form property lets you disable the submit button if the itemForm.form.valid is invalid.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content7_3>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Template variable scope
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content7_3_Inner>
                                            <p>Refer to a template variable anywhere within its surrounding template. Structural directives, such as *ngIf and *ngFor, or < ng-template> act as a template boundary. You cannot access template variables outside of these boundaries.</p>
                                            <p class="note">Define a variable only once in the template so the runtime value remains predictable.</p>

                                            <ng-container #content7_3_1>
                                                <mat-accordion>
                                                  <mat-expansion-panel>
                                                      <mat-expansion-panel-header>
                                                          <mat-panel-title>
                                                            An inner template can access template variables that the outer template defines.
                                                          </mat-panel-title>
                                                      </mat-expansion-panel-header>
                                      
                                                      <ng-container #content7Content_3_1>
                                                          <ng-container #description_7_3_1>
                                                              <p>In the following example, changing the text in the < input> changes the value in the < span> because Angular immediately updates changes through the template variable, ref1.</p>
                                                              <code-example code="
                                                              <input #ref1 type='text' [(ngModel)]='firstExample' />
                                                              <span *ngIf='true'>Value: [[ ref1.value ]]</span>
                                                              "></code-example>

                                                              <p>In this case, there is an implied < ng-template> around the < span> and the definition of the variable is outside of it. Accessing a template variable from the parent template works because the child template inherits the context from the parent template.</p>
                                                                <p>Rewriting the preceding code in a more verbose form explicitly shows the < ng-template>.</p>

                                                                <code-example code="
                                                                <input #ref1 type='text' [(ngModel)]='firstExample' />

                                                                <!-- New template -->
                                                                <ng-template [ngIf]='true'>
                                                                  <!-- Because the context is inherited, the value is available to the new template -->
                                                                  <span>Value: [[ ref1.value ]]</span>
                                                                </ng-template>
                                                                "></code-example>

                                                                <p>However, accessing a template variable from outside the parent template doesn't work.</p>
                                                                <code-example code="
                                                                <input *ngIf='true' #ref2 type='text' [(ngModel)]='secondExample' />
                                                                <span>Value: [[ ref2?.value ]]</span> <!-- doesn't work -->
                                                                "></code-example>

                                                                <p>The verbose form shows that ref2 is outside the parent template.</p>
                                                                <code-example code="
                                                                <ng-template [ngIf]='true'>
                                                                    <!-- The reference is defined within a template -->
                                                                    <input #ref2 type='text' [(ngModel)]='secondExample' />
                                                                  </ng-template>
                                                                  <!-- ref2 accessed from outside that template doesn't work -->
                                                                  <span>Value: [[ ref2?.value ]]</span>
                                                                "></code-example>

                                                                <p>Consider the following example that uses *ngFor.</p>
                                                                <code-example code="
                                                                <ng-container *ngFor='let i of [1,2]'>
                                                                    <input #ref type='text' [value]='i' />
                                                                  </ng-container>
                                                                  [[ ref.value ]]
                                                                "></code-example>

                                                                <p>Here, ref.value doesn't work. The structural directive, *ngFor instantiates the template twice because *ngFor iterates over the two items in the array. It is impossible to define what the ref.value reference signifies.</p>
                                                                <p>With structural directives, such as *ngFor or *ngIf, there is no way for Angular to know if a template is ever instantiated.</p>
                                                                <p>As a result, Angular isn't able to access the value and returns an error.</p>
                                                          </ng-container>
                                                    </ng-container>
                                                  </mat-expansion-panel>
                                                </mat-accordion>
                                            </ng-container>

                                            <ng-container #content7_3_2>
                                                <mat-accordion>
                                                  <mat-expansion-panel>
                                                      <mat-expansion-panel-header>
                                                          <mat-panel-title>
                                                            Accessing a template variable within < ng-template>
                                                          </mat-panel-title>
                                                      </mat-expansion-panel-header>
                                      
                                                      <ng-container #content7Content_3_2>
                                                          <ng-container #description_7_3_2>
                                                              <p>When you declare the variable on an < ng-template>, the variable refers to a TemplateRef instance, which represents the template.</p>
                                                              <code-example code="
                                                              <ng-template #ref3></ng-template>
                                                              <button (click)='log(ref3)'>Log type of #ref</button>
                                                              "></code-example>

                                                              <p>In this example, clicking the button calls the log() function, which outputs the value of #ref3 to the console. Because the #ref variable is on an < ng-template>, the value is TemplateRef.</p>
                                                              <p>The following is the expanded browser console output of the TemplateRef() function with the name of TemplateRef.</p>
                                                              <code-example code="
                                                              ▼ ƒ TemplateRef()
                                                              name: 'TemplateRef'
                                                              __proto__: Function
                                                              "></code-example>
                                                          </ng-container>
                                                    </ng-container>
                                                  </mat-expansion-panel>
                                                </mat-accordion>
                                            </ng-container>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>

                            <ng-container #content7_4>
                                <mat-accordion>
                                    <mat-expansion-panel>
                                        <mat-expansion-panel-header>
                                            <mat-panel-title>
                                                Template input variable
                                            </mat-panel-title>
                                        </mat-expansion-panel-header>
                    
                                        <ng-container #content7_4_Inner>
                                            <p>A template input variable is a variable to reference within a single instance of the template. You declare a template input variable using the let keyword as in let hero.</p>
                                            <p>There are several such variables in this example: hero, i, and odd.</p>
                                            <code-example code="
                                            <ng-template #hero let-hero let-i='index' let-odd='isOdd'>
                                                <div [class]='{'odd-row': odd}'>[[i]]:[[hero.name]]</div>
                                              </ng-template>
                                            "></code-example>

                                            <p>The variable's scope is limited to a single instance of the repeated template. Use the same variable name again in the definition of other structural directives.</p>
                                            <p>In contrast, you declare a template variable by prefixing the variable name with #, as in #var. A template variable refers to its attached element, component, or directive.</p>
                                            <p>Template input variables and template variables names have their own namespaces. The template input variable hero in let hero is distinct from the template variable hero in #hero.</p>
                                        </ng-container>
                                    </mat-expansion-panel>
                                </mat-accordion>
                            </ng-container>
                        </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #workspaceTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Workspace and project structure
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #workspaceContent>
            <ng-container #description></ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #ngModulesTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            NgModules
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #ngModulesContent>
            <ng-container #description></ng-container>

            <ng-container #content1>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            NgModules Introduction
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content1Content>
                        <ng-container #description_1>
                            <p>NgModules configure the injector and the compiler and help organize related things together.</p>
                            <p>An NgModule is a class marked by the @NgModule decorator. @NgModule takes a metadata object that describes how to compile a component's template and how to create an injector at runtime. It identifies the module's own components, directives, and pipes, making some of them public, through the exports property, so that external components can use them. @NgModule can also add service providers to the application dependency injectors.</p>
                        </ng-container>

                        <ng-container #content1_1_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Angular modularity
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content1_1_Inner_1>
                                        <p>Modules are a great way to organize an application and extend it with capabilities from external libraries.</p>
                                        <p>Angular libraries are NgModules, such as FormsModule, HttpClientModule, and RouterModule. Many third-party libraries are available as NgModules such as Material Design, Ionic, and AngularFire2.</p>
                                        <p>NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities.</p>
                                        <p>Modules can also add services to the application. Such services might be internally developed, like something you'd develop yourself or come from outside sources, such as the Angular router and HTTP client.</p>
                                        <p>Modules can be loaded eagerly when the application starts or lazy loaded asynchronously by the router.</p>
                                        <p>NgModule metadata does the following:</p>
                                        <ul>
                                            <li>Declares which components, directives, and pipes belong to the module.</li>
                                            <li>Makes some of those components, directives, and pipes public so that other module's component templates can use them.</li>
                                            <li>Imports other modules with the components, directives, and pipes that components in the current module need.</li>
                                            <li>Provides services that other application components can use.</li>
                                        </ul>

                                        <p>Every Angular application has at least one module, the root module. You bootstrap that module to launch the application.</p>
                                        <p>The root module is all you need in an application with few components. As the application grows, you refactor the root module into feature modules that represent collections of related functionality. You then import these modules into the root module.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_1_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The basic NgModule
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content1_1_Inner_2>
                                        <p>The Angular CLI generates the following basic AppModule when creating a new application.</p>
                                        <code-example code="
                                        // imports
                                        import { BrowserModule } from '@angular/platform-browser';
                                        import { NgModule } from '@angular/core';
                                        
                                        import { AppComponent } from './app.component';
                                        
                                        // @NgModule decorator with its metadata
                                        @NgModule({
                                          declarations: [AppComponent],
                                          imports: [BrowserModule],
                                          providers: [],
                                          bootstrap: [AppComponent]
                                        })
                                        export class AppModule {}
                                        "></code-example>

                                        <p>At the top are the import statements. The next section is where you configure the @NgModule by stating what components and directives belong to it (declarations) as well as which other modules it uses (imports). For more information on the structure of an @NgModule, be sure to read Bootstrapping.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            JavaScript modules vs. NgModules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content2Content>
                        <ng-container #description_2>
                            <p>JavaScript modules and NgModules can help you modularize your code, but they are very different. Angular applications rely on both kinds of modules.</p>
                        </ng-container>

                        <ng-container #content2_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            JavaScript modules: Files containing code
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content2_1_Inner>
                                        <p>A JavaScript module is an individual file with JavaScript code, usually containing a class or a library of functions for a specific purpose within your application. JavaScript modules let you spread your work across multiple files.</p>
                                        <p class="note">
                                            To learn more about JavaScript modules, see ES6 In Depth: Modules. For the module specification, see the 6th Edition of the ECMAScript standard.
                                        </p>
                                        <p>To make the code in a JavaScript module available to other modules, use an export statement at the end of the relevant code in the module, such as the following:</p>
                                        <code-example code="
                                        export class AppComponent { ... }
                                        "></code-example>

                                        <p>When you need that module’s code in another module, use an import statement as follows:</p>
                                        <code-example code="
                                        import { AppComponent } from './app.component';
                                        "></code-example>

                                        <p>Each module has its own top-level scope. In other words, top-level variables and functions in a module are not seen in other scripts or modules. Each module provides a namespace for identifiers to prevent them from clashing with identifiers in other modules. With multiple modules, you can prevent accidental global variables by creating a single global namespace and adding sub-modules to it.</p>
                                        <p>The Angular framework itself is loaded as a set of JavaScript modules.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            NgModules: Classes with metadata for compiling
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content2_2_Inner>
                                        <p>An NgModule is a class marked by the @NgModule decorator with a metadata object that describes how that particular part of the application fits together with the other parts. NgModules are specific to Angular. While classes with an @NgModule decorator are by convention kept in their own files, they differ from JavaScript modules because they include this metadata.</p>
                                        <p>The @NgModule metadata plays an important role in guiding the Angular compilation process that converts the application code you write into highly performant JavaScript code. The metadata describes how to compile a component's template and how to create an injector at runtime. It identifies the NgModule's components, directives, and pipes, and makes some of them public through the exports property so that external components can use them. You can also use an NgModule to add providers for services, so that the services are available elsewhere in your application.</p>
                                        <p>Rather than defining all member classes in one giant file as a JavaScript module, declare which components, directives, and pipes belong to the NgModule in the @NgModule.declarations list. These classes are called declarables. An NgModule can export only the declarable classes it owns or imports from other NgModules. It doesn't declare or export any other kind of class. Declarables are the only classes that matter to the Angular compilation process.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            An example that uses both
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content2_3_Inner>
                                        <p>The root NgModule AppModule generated by the Angular CLI for a new application project demonstrates how you use both kinds of modules:</p>
                                        <code-example code="
                                        // imports
                                        import { BrowserModule } from '@angular/platform-browser';
                                        import { NgModule } from '@angular/core';
                                        
                                        import { AppComponent } from './app.component';
                                        
                                        // @NgModule decorator with its metadata
                                        @NgModule({
                                          declarations: [AppComponent],
                                          imports: [BrowserModule],
                                          providers: [],
                                          bootstrap: [AppComponent]
                                        })
                                        export class AppModule {}
                                        "></code-example>

                                        <p>The root NgModule starts with import statements to import JavaScript modules. It then configures the @NgModule with the following arrays:</p>
                                        <ul>
                                            <li>declarations: The components, directives, and pipes that belong to the NgModule. A new application project's root NgModule has only one component, called AppComponent.</li>
                                            <li>imports: Other NgModules you are using, so that you can use their declarables. The newly generated root NgModule imports BrowserModule in order to use browser-specific services such as DOM rendering, sanitization, and location.</li>
                                            <li>providers: Providers of services that components in other NgModules can use. There are no providers in a newly generated root NgModule.</li>
                                            <li>bootstrap: The entry component that Angular creates and inserts into the index.html host web page, thereby bootstrapping the application. This entry component, AppComponent, appears in both the declarations and the bootstrap arrays.</li>
                                        </ul>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Launching your app with a root module
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content3Content>
                        <ng-container #description_3>
                            <p>An NgModule describes how the application parts fit together. Every application has at least one Angular module, the root module, which must be present for bootstrapping the application on launch. By convention and by default, this NgModule is named AppModule.</p>
                            <p>When you use the Angular CLI command ng new to generate an app, the default AppModule looks like the following:</p>
                            <code-example code="
                            /* JavaScript imports */
                            import { BrowserModule } from '@angular/platform-browser';
                            import { NgModule } from '@angular/core';
                            
                            import { AppComponent } from './app.component';
                            
                            /* the AppModule class with the @NgModule decorator */
                            @NgModule({
                              declarations: [
                                AppComponent
                              ],
                              imports: [
                                BrowserModule
                              ],
                              providers: [],
                              bootstrap: [AppComponent]
                            })
                            export class AppModule { }
                            "></code-example>

                            <p>After the import statements is a class with the @NgModule decorator.</p>
                            <p>The @NgModule decorator identifies AppModule as an NgModule class. @NgModule takes a metadata object that tells Angular how to compile and launch the application.</p>
                            <ul>
                                <li>declarations—this application's lone component.</li>
                                <li>imports—import BrowserModule to have browser specific services such as DOM rendering, sanitization, and location.</li>
                                <li>providers—the service providers.</li>
                                <li>bootstrap—the root component that Angular creates and inserts into the index.html host web page.</li>
                            </ul>
                            <p>The default application created by the Angular CLI only has one component, AppComponent, so it is in both the declarations and the bootstrap arrays.</p>
                        </ng-container>

                        <ng-container #content3_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The declarations array
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content3_1_Inner>
                                        <p>The module's declarations array tells Angular which components belong to that module. As you create more components, add them to declarations.</p>
                                        <p>You must declare every component in exactly one NgModule class. If you use a component without declaring it, Angular returns an error message.</p>
                                        <p>The declarations array only takes declarables. Declarables are components, directives and pipes. All of a module's declarables must be in the declarations array. Declarables must belong to exactly one module. The compiler emits an error if you try to declare the same class in more than one module.</p>
                                        <p>These declared classes are visible within the module but invisible to components in a different module unless they are exported from this module and the other module imports this one.</p>
                                        <p>An example of what goes into a declarations array follows:</p>
                                        <code-example code="
                                        declarations: [
                                        YourComponent,
                                        YourPipe,
                                        YourDirective
                                      ],
                                        "></code-example>

                                        <p>A declarable can only belong to one module, so only declare it in one @NgModule. When you need it elsewhere, import the module that has the declarable you need in it.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content3_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Using directives with @NgModule
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content3_2_Inner>
                                        <p>Use the declarations array for directives. To use a directive, component, or pipe in a module, you must do a few things:</p>
                                        <ol>
                                            <li>Export it from the file where you wrote it.</li>
                                            <li>Import it into the appropriate module.</li>
                                            <li>Declare it in the @NgModule declarations array.</li>
                                        </ol>
                                        <p>Those three steps look like the following. In the file where you create your directive, export it. The following example, named ItemDirective is the default directive structure that the CLI generates in its own file, item.directive.ts:</p>
                                        <code-example code="
                                        import { Directive } from '@angular/core';

                                        @Directive({
                                          selector: '[appItem]'
                                        })
                                        export class ItemDirective {
                                        // code goes here
                                          constructor() { }
                                        
                                        }
                                        "></code-example>

                                        <p>The key point here is that you have to export it so you can import it elsewhere. Next, import it into the NgModule, in this example app.module.ts, with a JavaScript import statement:</p>
                                        <code-example code="
                                        import { ItemDirective } from './item.directive';
                                        "></code-example>

                                        <p>And in the same file, add it to the @NgModule declarations array:</p>
                                        <code-example code="
                                        declarations: [
                                        AppComponent,
                                        ItemDirective
                                      ],
                                        "></code-example>

                                        <p>Now you could use your ItemDirective in a component. This example uses AppModule, but you'd do it the same way for a feature module. For more about directives, see Attribute Directives and Structural Directives. You'd also use the same technique for pipes and components.</p>
                                        <p>Remember, components, directives, and pipes belong to one module only. You only need to declare them once in your application because you share them by importing the necessary modules. This saves you time and helps keep your application lean.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content3_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The imports array
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content3_3_Inner>
                                        <p>The module's imports array appears exclusively in the @NgModule metadata object. It tells Angular about other NgModules that this particular module needs to function properly.</p>
                                        <code-example code="
                                        imports: [
                                        BrowserModule,
                                        FormsModule,
                                        HttpClientModule
                                      ],
                                        "></code-example>
                                        <p>This list of modules are those that export components, directives, or pipes that component templates in this module reference. In this case, the component is AppComponent, which references components, directives, or pipes in BrowserModule, FormsModule, or HttpClientModule. A component template can reference another component, directive, or pipe when the referenced class is declared in this module or the class was imported from another module.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content3_4>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The providers array
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content3_4_Inner>
                                        <p>The providers array is where you list the services the application needs. When you list services here, they are available app-wide. You can scope them when using feature modules and lazy loading. For more information, see Providers.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content3_5>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The bootstrap array
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content3_5_Inner>
                                        <p>The application launches by bootstrapping the root AppModule, which is also referred to as an entryComponent. Among other things, the bootstrapping process creates the component(s) listed in the bootstrap array and inserts each one into the browser DOM.</p>
                                        <p>Each bootstrapped component is the base of its own tree of components. Inserting a bootstrapped component usually triggers a cascade of component creations that fill out that tree.</p>
                                        <p>While you can put more than one component tree on a host web page, most applications have only one component tree and bootstrap a single root component.</p>
                                        <p>This one root component is usually called AppComponent and is in the root module's bootstrap array.</p>
                                        <p>In a situation where you want to bootstrap a component based on an API response, or you want to mount the AppComponent in a different DOM node that doesn't match the component selector, please refer to ApplicationRef.bootstrap() documentation.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Frequently-used modules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content4Content>
                        <ng-container #description_4>
                            <p>An Angular application needs at least one module that serves as the root module. As you add features to your app, you can add them in modules. The following are frequently used Angular modules with examples of some of the things they contain:</p>
                            <table>
                                <thead>
                                    <tr>
                                        <td>NgModule</td>
                                        <td>Import it from</td>
                                        <td>Why you use it</td>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>BrowserModule</td>
                                        <td>@angular/platform-browser</td>
                                        <td>When you want to run your application in a browser</td>
                                    </tr>
                                    <tr>
                                        <td>CommonModule</td>
                                        <td>@angular/common</td>
                                        <td>When you want to use NgIf, NgFor</td>
                                    </tr>
                                    <tr>
                                        <td>FormsModule</td>
                                        <td>@angular/forms</td>
                                        <td>When you want to build template driven forms (includes NgModel)</td>
                                    </tr>
                                    <tr>
                                        <td>ReactiveFormsModule	</td>
                                        <td>@angular/forms</td>
                                        <td>When you want to use RouterLink, .forRoot(), and .forChild()</td>
                                    </tr>
                                    <tr>
                                        <td>RouterModule</td>
                                        <td>@angular/router</td>
                                        <td>When you want to use RouterLink, .forRoot(), and .forChild()</td>
                                    </tr>
                                    <tr>
                                        <td>HttpClientModule</td>
                                        <td>@angular/common/http	</td>
                                        <td>When you want to talk to a server</td>
                                    </tr>
                                </tbody>
                            </table>
                        </ng-container>

                        <ng-container #content4_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Importing modules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content4_1_Inner>
                                        <p>When you use these Angular modules, import them in AppModule, or your feature module as appropriate, and list them in the @NgModule imports array. For example, in the basic application generated by the Angular CLI, BrowserModule is the first import at the top of the AppModule, app.module.ts.</p>
                                        <code-example code="
                                        /* import modules so that AppModule can access them */
                                        import { BrowserModule } from '@angular/platform-browser';
                                        import { NgModule } from '@angular/core';
                                        
                                        import { AppComponent } from './app.component';
                                        
                                        @NgModule({
                                          declarations: [
                                            AppComponent
                                          ],
                                          imports: [ /* add modules here so Angular knows to use them */
                                            BrowserModule,
                                          ],
                                          providers: [],
                                          bootstrap: [AppComponent]
                                        })
                                        export class AppModule { }
                                        "></code-example>
                                        <p>The imports at the top of the array are JavaScript import statements while the imports array within @NgModule is Angular specific. For more information on the difference, see JavaScript Modules vs. NgModules.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content4_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            BrowserModule and CommonModule
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content4_2_Inner>
                                        <p>BrowserModule imports CommonModule, which contributes many common directives such as ngIf and ngFor. Additionally, BrowserModule re-exports CommonModule making all of its directives available to any module that imports BrowserModule.</p>
                                        <p>For applications that run in the browser, import BrowserModule in the root AppModule because it provides services that are essential to launch and run a browser application. BrowserModule’s providers are for the whole application so it should only be in the root module, not in feature modules. Feature modules only need the common directives in CommonModule; they don’t need to re-install app-wide providers.</p>
                                        <p>If you do import BrowserModule into a lazy loaded feature module, Angular returns an error telling you to use CommonModule instead.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Guidelines for creating NgModules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content5Content>
                        <ng-container #description_5>
                            <p>This topic provides a conceptual overview of the different categories of NgModules you can create in order to organize your code in a modular structure. These categories are not cast in stone—they are suggestions. You may want to create NgModules for other purposes, or combine the characteristics of some of these categories.</p>
                            <p>NgModules are a great way to organize an application and keep code related to a specific functionality or feature separate from other code. Use NgModules to consolidate components, directives, and pipes into cohesive blocks of functionality. Focus each block on a feature or business domain, a workflow or navigation flow, a common collection of utilities, or one or more providers for services.</p>
                            <p></p>
                        </ng-container>

                        <ng-container #content5_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Summary of NgModule categories
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_1_Inner>
                                        <p>All applications start by bootstrapping a root NgModule. You can organize your other NgModules any way you want.</p>
                                        <p>This topic provides some guidelines for the following general categories of NgModules:</p>
                                        <ul>
                                            <li>Domain: A domain NgModule is organized around a feature, business domain, or user experience.</li>
                                            <li>Routed: The top component of the NgModule acts as the destination of a router navigation route.</li>
                                            <li>Routing: A routing NgModule provides the routing configuration for another NgModule.</li>
                                            <li>Service: A service NgModule provides utility services such as data access and messaging.</li>
                                            <li>Widget: A widget NgModule makes a component, directive, or pipe available to other NgModules.</li>
                                            <li>Shared: A shared NgModule makes a set of components, directives, and pipes available to other NgModules.</li>
                                        </ul>

                                        <p>The following table summarizes the key characteristics of each category.</p>

                                        <table>
                                            <thead>
                                                <tr>
                                                    <td>NgModule</td>
                                                    <td>Declarations</td>
                                                    <td>Providers</td>
                                                    <td>Exports</td>
                                                    <td>Imported by</td>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Domain</td>
                                                    <td>Yes</td>
                                                    <td>Rare</td>
                                                    <td>Top component</td>
                                                    <td>Another domain, AppModule</td>
                                                </tr>
                                                <tr>
                                                    <td>Routed</td>
                                                    <td>Yes</td>
                                                    <td>Rare</td>
                                                    <td>No</td>
                                                    <td>None</td>
                                                </tr>
                                                <tr>
                                                    <td>Routing</td>
                                                    <td>No</td>
                                                    <td>Yes (Guards)</td>
                                                    <td>RouterModule</td>
                                                    <td>Another domain (for routing)</td>
                                                </tr>
                                                <tr>
                                                    <td>Service</td>
                                                    <td>No</td>
                                                    <td>Yes</td>
                                                    <td>No</td>
                                                    <td>AppModule</td>
                                                </tr>
                                                <tr>
                                                    <td>Widget</td>
                                                    <td>Yes</td>
                                                    <td>Rare</td>
                                                    <td>Yes</td>
                                                    <td>Another domain</td>
                                                </tr>
                                                <tr>
                                                    <td>Shared</td>
                                                    <td>Yes</td>
                                                    <td>No</td>
                                                    <td>Yes</td>
                                                    <td>Another domain</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Domain NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_2_Inner>
                                        <p>Use a domain NgModule to deliver a user experience dedicated to a particular feature or application domain, such as editing a customer or placing an order. </p>
                                        <p>A domain NgModule organizes the code related to a certain function, containing all of the components, routing, and templates that make up the function. Your top component in the domain NgModule acts as the feature or domain's root, and is the only component you export. Private supporting subcomponents descend from it.</p>
                                        <p>Import a domain NgModule exactly once into another NgModule, such as a domain NgModule, or into the root NgModule (AppModule) of an application that contains only a few NgModules.</p>
                                        <p>Domain NgModules consist mostly of declarations. You rarely include providers. If you do, the lifetime of the provided services should be the same as the lifetime of the NgModule.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Routed NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_3_Inner>
                                        <p>Use a routed NgModule for all lazy-loaded NgModules. Use the top component of the NgModule as the destination of a router navigation route. Routed NgModules don’t export anything because their components never appear in the template of an external component.</p>
                                        <p>Don't import a lazy-loaded routed NgModule into another NgModule, as this would trigger an eager load, defeating the purpose of lazy loading.</p>
                                        <p>Routed NgModules rarely have providers because you load a routed NgModule only when needed (such as for routing). Services listed in the NgModules' provider array would not be available because the root injector wouldn’t know about the lazy-loaded NgModule. If you include providers, the lifetime of the provided services should be the same as the lifetime of the NgModule. Don't provide app-wide singleton services in a routed NgModule or in an NgModule that the routed NgModule imports.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_4>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Routing NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_4_Inner>
                                        <p>Use a routing NgModule to provide the routing configuration for a domain NgModule, thereby separating routing concerns from its companion domain NgModule. One example is ContactRoutingModule in the live example / download example, which provides the routing for its companion domain NgModule ContactModule.</p>
                                        <p>Use a routing NgModule to do the following tasks:</p>
                                        <ul>
                                            <li>Define routes.</li>
                                            <li>Add router configuration to the NgModule's import.</li>
                                            <li>Add guard and resolver service providers to the NgModule's providers.</li>
                                        </ul>
                                        <p>The name of the routing NgModule should parallel the name of its companion NgModule, using the suffix Routing. For example, ContactModule in contact.module.ts has a routing NgModule named ContactRoutingModule in contact-routing.module.ts.</p>
                                        <p>Import a routing NgModule only into its companion NgModule. If the companion NgModule is the root AppModule, the AppRoutingModule adds router configuration to its imports with RouterModule.forRoot(routes). All other routing NgModules are children that import RouterModule.forChild(routes).</p>
                                        <p>In your routing NgModule, re-export the RouterModule as a convenience so that components of the companion NgModule have access to router directives such as RouterLink and RouterOutlet.</p>
                                        <p>Don't use declarations in a routing NgModule. Components, directives, and pipes are the responsibility of the companion domain NgModule, not the routing NgModule.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_5>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Service NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_5_Inner>
                                        <p>Use a service NgModule to provide a utility service such as data access or messaging. Ideal service NgModules consist entirely of providers and have no declarations. Angular's HttpClientModule is a good example of a service NgModule.</p>
                                        <p>Use only the root AppModule to import service NgModules.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_6>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Widget NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_6_Inner>
                                        <p>Use a widget NgModule to make a component, directive, or pipe available to external NgModules. Import widget NgModules into any NgModules that need the widgets in their templates. Many third-party UI component libraries are provided as widget NgModules.</p>
                                        <p>A widget NgModule should consist entirely of declarations, most of them exported. It would rarely have providers.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_7>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Shared NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content5_7_Inner>
                                        <p>Put commonly used directives, pipes, and components into one NgModule, typically named SharedModule, and then import just that NgModule wherever you need it in other parts of your application. You can import the shared NgModule in your domain NgModules, including lazy-loaded NgModules. One example is SharedModule in the live example / download example, which provides the AwesomePipe custom pipe and HighlightDirective directive.</p>
                                        <p>Shared NgModules should not include providers, nor should any of its imported or re-exported NgModules include providers.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content6>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Entry components
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content6Content>
                        <ng-container #description_6>
                            <p class="note">
                                Entry components have been deprecated with the Ivy rendering engine. For more information, see entryComponents deprecation in the Deprecated APIs and features.
                            </p>
                            <p>An entry component is any component that Angular loads imperatively, (which means you’re not referencing it in the template), by type. You specify an entry component by bootstrapping it in an NgModule, or including it in a routing definition.</p>
                            <p class="note">
                                To contrast the two types of components, there are components which are included in the template, which are declarative. Additionally, there are components which you load imperatively; that is, entry components.
                            </p>

                            <p>There are two main kinds of entry components:</p>
                            <ul>
                                <li>The bootstrapped root component.</li>
                                <li>A component you specify in a route definition.</li>
                            </ul>
                        </ng-container>

                        <ng-container #content6_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            A bootstrapped entry component
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content6_1_Inner>
                                        <p>The following is an example of specifying a bootstrapped component, AppComponent, in a basic app.module.ts:</p>
                                        <code-example code="
                                        @NgModule({
                                            declarations: [
                                              AppComponent
                                            ],
                                            imports: [
                                              BrowserModule,
                                              FormsModule,
                                              HttpClientModule,
                                              AppRoutingModule
                                            ],
                                            providers: [],
                                            bootstrap: [AppComponent] // bootstrapped entry component
                                          })
                                        "></code-example>
                                        <p>A bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process (application launch). Other entry components are loaded dynamically by other means, such as with the router.</p>
                                        <p>Angular loads a root AppComponent dynamically because it's listed by type in @NgModule.bootstrap.</p>
                                        <p class="note">
                                            A component can also be bootstrapped imperatively in the module's ngDoBootstrap() method. The @NgModule.bootstrap property tells the compiler that this is an entry component and it should generate code to bootstrap the application with this component.
                                        </p>
                                        <p>A bootstrapped component is necessarily an entry component because bootstrapping is an imperative process, thus it needs to have an entry component.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content6_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            A routed entry component
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content6_2_Inner>
                                        <p>The second kind of entry component occurs in a route definition like this:</p>
                                        <code-example code="
                                        const routes: Routes = [
                                        {
                                          path: '',
                                          component: CustomerListComponent
                                        }
                                      ];
                                        "></code-example>

                                        <p>A route definition refers to a component by its type with component: CustomerListComponent.</p>
                                        <p>All router components must be entry components. Because this would require you to add the component in two places (router and entryComponents) the Compiler is smart enough to recognize that this is a router definition and automatically add the router component into entryComponents.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content6_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The entryComponents array
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content6_3_Inner>
                                        <p class="note">Since 9.0.0 with Ivy, the entryComponents property is no longer necessary. See deprecations guide.</p>
                                        <p>Though the @NgModule decorator has an entryComponents array, most of the time you won't have to explicitly set any entry components because Angular adds components listed in @NgModule.bootstrap and those in route definitions to entry components automatically. Though these two mechanisms account for most entry components, if your application happens to bootstrap or dynamically load a component by type imperatively, you must add it to entryComponents explicitly.</p>

                                        <br>
                                        <h3>entryComponents and the compiler</h3>
                                        <p>For production applications you want to load the smallest code possible. The code should contain only the classes that you actually need and exclude components that are never used. For this reason, the Angular compiler only generates code for components which are reachable from the entryComponents; This means that adding more references to @NgModule.declarations does not imply that they will necessarily be included in the final bundle.</p>
                                        <p>In fact, many libraries declare and export components you'll never use. For example, a material design library will export all components because it doesn’t know which ones you will use. However, it is unlikely that you will use them all. For the ones you don't reference, the tree shaker drops these components from the final code package.</p>
                                        <p>If a component isn't an entry component and isn't found in a template, the tree shaker will throw it away. So, it's best to add only the components that are truly entry components to help keep your app as trim as possible.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content7>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Feature modules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content7Content>
                        <ng-container #description_7>
                            <p>Feature modules are NgModules for the purpose of organizing code.</p>
                            <p>As your application grows, you can organize code relevant for a specific feature. This helps apply clear boundaries for features. With feature modules, you can keep code related to a specific functionality or feature separate from other code. Delineating areas of your application helps with collaboration between developers and teams, separating directives, and managing the size of the root module.</p>
                        </ng-container>

                        <ng-container #content7_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Feature modules vs. root modules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content7_1_Inner>
                                        <p>A feature module is an organizational best practice, as opposed to a concept of the core Angular API. A feature module delivers a cohesive set of functionality focused on a specific application need such as a user workflow, routing, or forms. While you can do everything within the root module, feature modules help you partition the application into focused areas. A feature module collaborates with the root module and with other modules through the services it provides and the components, directives, and pipes that it shares.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content7_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            How to make a feature module
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content7_2_Inner>
                                        <p>Assuming you already have an application that you created with the Angular CLI, create a feature module using the CLI by entering the following command in the root project directory. Replace CustomerDashboard with the name of your module. You can omit the "Module" suffix from the name because the CLI appends it:</p>
                                        <code-example code="
                                        ng generate module CustomerDashboard
                                        "></code-example>
                                        <p>This causes the CLI to create a folder called customer-dashboard with a file inside called customer-dashboard.module.ts with the following contents:</p>
                                        <code-example code="
                                        import { NgModule } from '@angular/core';
                                        import { CommonModule } from '@angular/common';
                                        
                                        @NgModule({
                                          imports: [
                                            CommonModule
                                          ],
                                          declarations: []
                                        })
                                        export class CustomerDashboardModule { }
                                        "></code-example>
                                        <p>The structure of an NgModule is the same whether it is a root module or a feature module. In the CLI generated feature module, there are two JavaScript import statements at the top of the file: the first imports NgModule, which, like the root module, lets you use the @NgModule decorator; the second imports CommonModule, which contributes many common directives such as ngIf and ngFor. Feature modules import CommonModule instead of BrowserModule, which is only imported once in the root module. CommonModule only contains information for common directives such as ngIf and ngFor which are needed in most templates, whereas BrowserModule configures the Angular application for the browser which needs to be done only once.</p>
                                        <p>The declarations array is available for you to add declarables, which are components, directives, and pipes that belong exclusively to this particular module. To add a component, enter the following command at the command line where customer-dashboard is the directory where the CLI generated the feature module and CustomerDashboard is the name of the component:</p>
                                        <code-example code="
                                        ng generate component customer-dashboard/CustomerDashboard
                                        "></code-example>
                                        <p>This generates a folder for the new component within the customer-dashboard folder and updates the feature module with the CustomerDashboardComponent info:</p>
                                        <code-example code="
                                        // import the new component
                                        import { CustomerDashboardComponent } from './customer-dashboard/customer-dashboard.component';
                                        
                                        @NgModule({
                                          imports: [
                                            CommonModule
                                          ],
                                          declarations: [
                                            CustomerDashboardComponent
                                          ],
                                        })
                                        "></code-example>
                                        <p>The CustomerDashboardComponent is now in the JavaScript import list at the top and added to the declarations array, which lets Angular know to associate this new component with this feature module.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content7_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Importing a feature module
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content7_3_Inner>
                                        <p>To incorporate the feature module into your app, you have to let the root module, app.module.ts, know about it. Notice the CustomerDashboardModule export at the bottom of customer-dashboard.module.ts. This exposes it so that other modules can get to it. To import it into the AppModule, add it to the imports in app.module.ts and to the imports array:</p>
                                        <code-example code="
                                        import { HttpClientModule } from '@angular/common/http';
                                        import { NgModule } from '@angular/core';
                                        import { FormsModule } from '@angular/forms';
                                        import { BrowserModule } from '@angular/platform-browser';
                                        
                                        import { AppComponent } from './app.component';
                                        // import the feature module here so you can add it to the imports array below
                                        import { CustomerDashboardModule } from './customer-dashboard/customer-dashboard.module';
                                        
                                        @NgModule({
                                          declarations: [
                                            AppComponent
                                          ],
                                          imports: [
                                            BrowserModule,
                                            FormsModule,
                                            HttpClientModule,
                                            CustomerDashboardModule // add the feature module here
                                          ],
                                          providers: [],
                                          bootstrap: [AppComponent]
                                        })
                                        export class AppModule { }
                                        "></code-example>
                                        <p>Now the AppModule knows about the feature module. If you were to add any service providers to the feature module, AppModule would know about those too, as would any other feature modules. However, NgModules don’t expose their components by default.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content7_4>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Rendering a feature module’s component template
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content7_4_Inner>
                                        <p>When the CLI generated the CustomerDashboardComponent for the feature module, it included a template, customer-dashboard.component.html, with the following markup:</p>
                                        <code-example code="
                                        <p>
                                            customer-dashboard works!
                                          </p>
                                        "></code-example>
                                        <p>To see this HTML in the AppComponent, you first have to export the CustomerDashboardComponent in the CustomerDashboardModule. In customer-dashboard.module.ts, just beneath the declarations array, add an exports array containing CustomerDashboardComponent:</p>
                                        <code-example code="
                                        exports: [
                                            CustomerDashboardComponent
                                            ]
                                        "></code-example>
                                        <p>Next, in the AppComponent, app.component.html, add the tag < app-customer-dashboard>:</p>
                                        <code-example code="
                                        <h1>
                                            [[title]]
                                          </h1>
                                          
                                          <!-- add the selector from the CustomerDashboardComponent -->
                                          <app-customer-dashboard></app-customer-dashboard>
                                        "></code-example>
                                        <p>Now, in addition to the title that renders by default, the CustomerDashboardComponent template renders too:</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content8>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Providing dependencies in modules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content8Content>
                        <ng-container #description_8>
                            <p>A provider is an instruction to the Dependency Injection system on how to obtain a value for a dependency. Most of the time, these dependencies are services that you create and provide.</p>
                        </ng-container>

                        <ng-container #content8_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Providing a service
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_1_Inner>
                                        <p>If you already have an application that was created with the Angular CLI, you can create a service using the ng generate CLI command in the root project directory. Replace User with the name of your service.</p>
                                        <code-example code="
                                        ng generate service User
                                        "></code-example>
                                        <p>This command creates the following UserService skeleton:</p>
                                        <code-example code="
                                        import { Injectable } from '@angular/core';

                                        @Injectable({
                                          providedIn: 'root',
                                        })
                                        export class UserService {
                                        }
                                        "></code-example>
                                        <p>You can now inject UserService anywhere in your application.</p>
                                        <p>The service itself is a class that the CLI generated and that's decorated with @Injectable(). By default, this decorator has a providedIn property, which creates a provider for the service. In this case, providedIn: 'root' specifies that Angular should provide the service in the root injector.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Provider scope
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_2_Inner>
                                        <p>When you add a service provider to the root application injector, it’s available throughout the application. Additionally, these providers are also available to all the classes in the application as long they have the lookup token.</p>
                                        <p>You should always provide your service in the root injector unless there is a case where you want the service to be available only if the consumer imports a particular @NgModule.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            providedIn and NgModules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_3_Inner>
                                        <p>It's also possible to specify that a service should be provided in a particular @NgModule. For example, if you don't want UserService to be available to applications unless they import a UserModule you've created, you can specify that the service should be provided in the module:</p>
                                        <code-example code="
                                        import { Injectable } from '@angular/core';
                                        import { UserModule } from './user.module';
                                        
                                        @Injectable({
                                          providedIn: UserModule,
                                        })
                                        export class UserService {
                                        }
                                        "></code-example>
                                        <p>The example above shows the preferred way to provide a service in a module. This method is preferred because it enables tree-shaking of the service if nothing injects it. If it's not possible to specify in the service which module should provide it, you can also declare a provider for the service within the module:</p>
                                        <code-example code="
                                        import { NgModule } from '@angular/core';

                                        import { UserService } from './user.service';
                                        
                                        @NgModule({
                                          providers: [UserService],
                                        })
                                        export class UserModule {
                                        }
                                        "></code-example>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_4>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Limiting provider scope by lazy loading modules
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_4_Inner>
                                        <p>In the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the application launches. Angular uses an injector system to make things available between modules. In an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the application.</p>
                                        <p>This behavior necessarily changes when you use lazy loading. Lazy loading is when you load modules only when you need them; for example, when routing. They aren’t loaded right away like with eagerly loaded modules. This means that any services listed in their provider arrays aren’t available because the root injector doesn’t know about these modules.</p>
                                        <p>When the Angular router lazy-loads a module, it creates a new injector. This injector is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.</p>
                                        <p>Any component created within a lazy loaded module’s context, such as by router navigation, gets the local instance of the service, not the instance in the root application injector. Components in external modules continue to receive the instance created for the application root.</p>
                                        <p>Though you can provide services by lazy loading modules, not all services can be lazy loaded. For instance, some modules only work in the root module, such as the Router. The Router works with the global location object in the browser.</p>
                                        <p>As of Angular version 9, you can provide a new instance of a service with each lazy loaded module. The following code adds this functionality to UserService.</p>
                                        <code-example code="
                                        import { Injectable } from '@angular/core';

                                        @Injectable({
                                          providedIn: 'any',
                                        })
                                        export class UserService {
                                        }
                                        "></code-example>
                                        <p>With providedIn: 'any', all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_5>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Limiting provider scope with components
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_5_Inner>
                                        <p>Another way to limit provider scope is by adding the service you want to limit to the component’s providers array. Component providers and NgModule providers are independent of each other. This method is helpful when you want to eagerly load a module that needs a service all to itself. Providing a service in the component limits the service only to that component and its descendants. Other components in the same module can’t access it.</p>
                                        <code-example code="
                                        @Component({
                                            /* . . . */
                                            providers: [UserService]
                                          })
                                        "></code-example>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_6>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Providing services in modules vs. components
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_6_Inner>
                                        <p>Generally, provide services the whole application needs in the root module and scope services by providing them in lazy loaded modules.</p>
                                        <p>The router works at the root level so if you put providers in a component, even AppComponent, lazy loaded modules, which rely on the router, can’t see them.</p>
                                        <p>Register a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components. For example, a user editing component, UserEditorComponent, that needs a private copy of a caching UserService should register the UserService with the UserEditorComponent. Then each new instance of the UserEditorComponent gets its own cached service instance.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content8_7>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Injector hierarchy and service instances
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content8_7_Inner>
                                        <p>Services are singletons within the scope of an injector, which means there is at most one instance of a service in a given injector.</p>
                                        <p>Angular DI has a hierarchical injection system, which means that nested injectors can create their own service instances. Whenever Angular creates a new instance of a component that has providers specified in @Component(), it also creates a new child injector for that instance. Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.</p>
                                        <p>Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content9>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Singleton services
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content9Content>
                        <ng-container #description_9>
                            <p>A singleton service is a service for which only one instance exists in an application.</p>
                        </ng-container>

                        <ng-container #content9_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Providing a singleton service
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content9_1_Inner>
                                        <p>There are two ways to make a service a singleton in Angular:</p>
                                        <ul>
                                            <li>Set the providedIn property of the @Injectable() to "root".</li>
                                            <li>Include the service in the AppModule or in a module that is only imported by the AppModule</li>
                                        </ul>
                                    </ng-container>

                                    <ng-container #content9_1_1>
                                        <mat-accordion>
                                            <mat-expansion-panel>
                                                <mat-expansion-panel-header>
                                                    <mat-panel-title>
                                                        Using providedIn
                                                    </mat-panel-title>
                                                </mat-expansion-panel-header>
                            
                                                <ng-container #content9_1_Inner_1>
                                                    <p>Beginning with Angular 6.0, the preferred way to create a singleton service is to set providedIn to root on the service's @Injectable() decorator. This tells Angular to provide the service in the application root.</p>
                                                    <code-example code="
                                                    import { Injectable } from '@angular/core';

                                                    @Injectable({
                                                      providedIn: 'root',
                                                    })
                                                    export class UserService {
                                                    }
                                                    "></code-example>
                                                </ng-container>
                                            </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content9_1_2>
                                        <mat-accordion>
                                            <mat-expansion-panel>
                                                <mat-expansion-panel-header>
                                                    <mat-panel-title>
                                                        NgModule providers array
                                                    </mat-panel-title>
                                                </mat-expansion-panel-header>
                            
                                                <ng-container #content9_1_Inner_2>
                                                    <p>In applications built with Angular versions prior to 6.0, services are registered NgModule providers arrays as follows:</p>
                                                    <code-example code="
                                                    @NgModule({
                                                        ...
                                                        providers: [UserService],
                                                        ...
                                                      }) 
                                                    "></code-example>
                                                    <p>If this NgModule were the root AppModule, the UserService would be a singleton and available throughout the application. Though you may see it coded this way, using the providedIn property of the @Injectable() decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.</p>
                                                </ng-container>
                                            </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content9_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            The forRoot() pattern
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content9_2_Inner>
                                        <p>Generally, you'll only need providedIn for providing services and forRoot()/forChild() for routing. However, understanding how forRoot() works to make sure a service is a singleton will inform your development at a deeper level.</p>
                                        <p>If a module defines both providers and declarations (components, directives, pipes), then loading the module in multiple feature modules would duplicate the registration of the service. This could result in multiple service instances and the service would no longer behave as a singleton.</p>
                                        <p>There are multiple ways to prevent this:</p>
                                        <ul>
                                            <li>Use the providedIn syntax instead of registering the service in the module.</li>
                                            <li>Separate your services into their own module.</li>
                                            <li>Define forRoot() and forChild() methods in the module.</li>
                                        </ul>
                                        <p class="note">
                                            Note: There are two example applications where you can see this scenario; the more advanced NgModules live example, which contains forRoot() and forChild() in the routing modules and the GreetingModule, and the simpler Lazy Loading live example. For an introductory explanation see the Lazy Loading Feature Modules guide.
                                        </p>
                                        <p>Use forRoot() to separate providers from a module so you can import that module into the root module with providers and child modules without providers.</p>
                                        <ol>
                                            <li>Create a static method forRoot() on the module.</li>
                                            <li>Place the providers into the forRoot() method.</li>
                                        </ol>
                                        <code-example code="
                                        static forRoot(config: UserServiceConfig): ModuleWithProviders<GreetingModule> {
                                            return {
                                              ngModule: GreetingModule,
                                              providers: [
                                                {provide: UserServiceConfig, useValue: config }
                                              ]
                                            };
                                          }
                                        "></code-example>
                                    </ng-container>

                                    <ng-container #content9_2_1>
                                        <mat-accordion>
                                            <mat-expansion-panel>
                                                <mat-expansion-panel-header>
                                                    <mat-panel-title>
                                                        forRoot() and the Router
                                                    </mat-panel-title>
                                                </mat-expansion-panel-header>
                            
                                                <ng-container #content9_2_Inner_1>
                                                    <p>RouterModule provides the Router service, as well as router directives, such as RouterOutlet and routerLink. The root application module imports RouterModule so that the application has a Router and the root application components can access the router directives. Any feature modules must also import RouterModule so that their components can place router directives into their templates.</p>
                                                    <p>If the RouterModule didn’t have forRoot() then each feature module would instantiate a new Router instance, which would break the application as there can only be one Router. By using the forRoot() method, the root application module imports RouterModule.forRoot(...) and gets a Router, and all feature modules import RouterModule.forChild(...) which does not instantiate another Router.</p>
                                                    <p class="note">
                                                        Note: If you have a module which has both providers and declarations, you can use this technique to separate them out and you may see this pattern in legacy applications. However, since Angular 6.0, the best practice for providing services is with the @Injectable() providedIn property.
                                                    </p>
                                                </ng-container>
                                            </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content9_2_2>
                                        <mat-accordion>
                                            <mat-expansion-panel>
                                                <mat-expansion-panel-header>
                                                    <mat-panel-title>
                                                        How forRoot() works
                                                    </mat-panel-title>
                                                </mat-expansion-panel-header>
                            
                                                <ng-container #content9_2_Inner_2>
                                                    <p>forRoot() takes a service configuration object and returns a ModuleWithProviders, which is a simple object with the following properties:</p>
                                                    <ul>
                                                        <li>ngModule: in this example, the GreetingModule class</li>
                                                        <li>providers: the configured providers</li>
                                                    </ul>
                                                    <p>In the live example / download example the root AppModule imports the GreetingModule and adds the providers to the AppModule providers. Specifically, Angular accumulates all imported providers before appending the items listed in @NgModule.providers. This sequence ensures that whatever you add explicitly to the AppModule providers takes precedence over the providers of imported modules.</p>
                                                    <p>The sample application imports GreetingModule and uses its forRoot() method one time, in AppModule. Registering it once like this prevents multiple instances.</p>
                                                    <p>You can also add a forRoot() method in the GreetingModule that configures the greeting UserService.</p>
                                                    <p>In the following example, the optional, injected UserServiceConfig extends the greeting UserService. If a UserServiceConfig exists, the UserService sets the user name from that config.</p>
                                                    <code-example code="
                                                    constructor(@Optional() config?: UserServiceConfig) {
                                                        if (config) { this._userName = config.userName; }
                                                      }
                                                    "></code-example>
                                                    <p>Here's forRoot() that takes a UserServiceConfig object:</p>
                                                    <code-example code="
                                                    static forRoot(config: UserServiceConfig): ModuleWithProviders<GreetingModule> {
                                                        return {
                                                          ngModule: GreetingModule,
                                                          providers: [
                                                            {provide: UserServiceConfig, useValue: config }
                                                          ]
                                                        };
                                                      }
                                                    "></code-example>
                                                    <p>Lastly, call it within the imports list of the AppModule. In the following snippet, other parts of the file are left out. For the complete file, see the live example / download example, or continue to the next section of this document.</p>
                                                    <code-example code="
                                                    import { GreetingModule } from './greeting/greeting.module';
                                                    @NgModule({
                                                      imports: [
                                                        GreetingModule.forRoot({userName: 'Miss Marple'}),
                                                      ],
                                                    })
                                                    "></code-example>
                                                    <p>The application displays "Miss Marple" as the user instead of the default "Sherlock Holmes".</p>
                                                    <p>Remember to import GreetingModule as a Javascript import at the top of the file and don't add it to more than one @NgModule imports list.</p>
                                                </ng-container>
                                            </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content9_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Prevent reimport of the GreetingModule
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content9_3_Inner>
                                        <p>Only the root AppModule should import the GreetingModule. If a lazy-loaded module imports it too, the application can generate multiple instances of a service.</p>
                                        <p>To guard against a lazy loaded module re-importing GreetingModule, add the following GreetingModule constructor.</p>
                                        <code-example code="
                                        constructor(@Optional() @SkipSelf() parentModule?: GreetingModule) {
                                            if (parentModule) {
                                              throw new Error(
                                                'GreetingModule is already loaded. Import it in the AppModule only');
                                            }
                                          }
                                        "></code-example>
                                        <p>The constructor tells Angular to inject the GreetingModule into itself. The injection would be circular if Angular looked for GreetingModule in the current injector, but the @SkipSelf() decorator means "look for GreetingModule in an ancestor injector, above me in the injector hierarchy."</p>
                                        <p>By default, the injector throws an error when it can't find a requested provider. The @Optional() decorator means not finding the service is OK. The injector returns null, the parentModule parameter is null, and the constructor concludes uneventfully.</p>
                                        <p>It's a different story if you improperly import GreetingModule into a lazy loaded module such as CustomersModule.</p>
                                        <p>Angular creates a lazy loaded module with its own injector, a child of the root injector. @SkipSelf() causes Angular to look for a GreetingModule in the parent injector, which this time is the root injector. Of course it finds the instance imported by the root AppModule. Now parentModule exists and the constructor throws the error.</p>
                                        <p>Here are the two files in their entirety for reference:</p>
                                        <code-example code="
                                        import { BrowserModule } from '@angular/platform-browser';
                                        import { NgModule } from '@angular/core';
                                        
                                        /* App Root */
                                        import { AppComponent } from './app.component';
                                        
                                        /* Feature Modules */
                                        import { ContactModule } from './contact/contact.module';
                                        import { GreetingModule } from './greeting/greeting.module';
                                        
                                        /* Routing Module */
                                        import { AppRoutingModule } from './app-routing.module';
                                        
                                        @NgModule({
                                          imports: [
                                            BrowserModule,
                                            ContactModule,
                                            GreetingModule.forRoot({userName: 'Miss Marple'}),
                                            AppRoutingModule
                                          ],
                                          declarations: [
                                            AppComponent
                                          ],
                                          bootstrap: [AppComponent]
                                        })
                                        export class AppModule { }
                                        "></code-example>

                                        <code-example code="
                                        import { ModuleWithProviders, NgModule, Optional, SkipSelf } from '@angular/core';

                                        import { CommonModule } from '@angular/common';
                                        
                                        import { GreetingComponent } from './greeting.component';
                                        import { UserServiceConfig } from './user.service';
                                        
                                        
                                        @NgModule({
                                          imports:      [ CommonModule ],
                                          declarations: [ GreetingComponent ],
                                          exports:      [ GreetingComponent ]
                                        })
                                        export class GreetingModule {
                                          constructor(@Optional() @SkipSelf() parentModule?: GreetingModule) {
                                            if (parentModule) {
                                              throw new Error(
                                                'GreetingModule is already loaded. Import it in the AppModule only');
                                            }
                                          }
                                        
                                          static forRoot(config: UserServiceConfig): ModuleWithProviders<GreetingModule> {
                                            return {
                                              ngModule: GreetingModule,
                                              providers: [
                                                {provide: UserServiceConfig, useValue: config }
                                              ]
                                            };
                                          }
                                        }
                                        "></code-example>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content10>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Sharing modules
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content10Content>
                        <ng-container #description_10>
                            <p>Creating shared modules allows you to organize and streamline your code. You can put commonly used directives, pipes, and components into one module and then import just that module wherever you need it in other parts of your application.</p>
                            <p>Consider the following module from an imaginary app:</p>
                            <code-example code="
                            import { CommonModule } from '@angular/common';
                            import { NgModule } from '@angular/core';
                            import { FormsModule } from '@angular/forms';
                            import { CustomerComponent } from './customer.component';
                            import { NewItemDirective } from './new-item.directive';
                            import { OrdersPipe } from './orders.pipe';
                            
                            @NgModule({
                             imports:      [ CommonModule ],
                             declarations: [ CustomerComponent, NewItemDirective, OrdersPipe ],
                             exports:      [ CustomerComponent, NewItemDirective, OrdersPipe,
                                             CommonModule, FormsModule ]
                            })
                            export class SharedModule { }
                            "></code-example>
                            <p>Note the following:</p>
                            <ul>
                                <li>It imports the CommonModule because the module's component needs common directives.</li>
                                <li>It declares and exports the utility pipe, directive, and component classes.</li>
                                <li>It re-exports the CommonModule and FormsModule.</li>
                            </ul>
                            <p>By re-exporting CommonModule and FormsModule, any other module that imports this SharedModule, gets access to directives like NgIf and NgFor from CommonModule and can bind to component properties with [(ngModel)], a directive in the FormsModule.</p>
                            <p>Even though the components declared by SharedModule might not bind with [(ngModel)] and there may be no need for SharedModule to import FormsModule, SharedModule can still export FormsModule without listing it among its imports. This way, you can give other modules access to FormsModule without having to import it directly into the @NgModule decorator.</p>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content11>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            NgModule API
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content11Content>
                        <ng-container #description_11>
                            <p>At a high level, NgModules are a way to organize Angular applications and they accomplish this through the metadata in the @NgModule decorator. The metadata falls into three categories:</p>
                            <ul>
                                <li>Static: Compiler configuration which tells the compiler about directive selectors and where in templates the directives should be applied through selector matching. This is configured using the declarations array.</li>
                                <li>Runtime: Injector configuration using the providers array.</li>
                                <li>Composability/Grouping: Bringing NgModules together and making them available using the imports and exports arrays.</li>
                            </ul>
                            <code-example code="
                            @NgModule({
                                // Static, that is compiler configuration
                                declarations: [], // Configure the selectors
                                entryComponents: [], // Generate the host factory
                              
                                // Runtime, or injector configuration
                                providers: [], // Runtime injector configuration
                              
                                // Composability / Grouping
                                imports: [], // composing NgModules together
                                exports: [] // making NgModules available to other parts of the app
                              })
                            "></code-example>

                            <br>
                            <h3>@NgModule metadata</h3>
                            <p>The following table summarizes the @NgModule metadata properties.</p>

                            <table>
                                <thead>
                                    <tr>
                                        <td>Property</td>
                                        <td>Description</td>
                                    </tr>
                                </thead>
                                <thead>
                                    <tr>
                                        <td>declarations</td>
                                        <td>
                                            <p>A list of declarable classes, (components, directives, and pipes) that belong to this module.</p>
                                            <ol>
                                                <li>When compiling a template, you need to determine a set of selectors which should be used for triggering their corresponding directives.</li>
                                                <li>
                                                    <p>The template is compiled within the context of an NgModule—the NgModule within which the template's component is declared—which determines the set of selectors using the following rules:</p>
                                                    <ul>
                                                        <li>All selectors of directives listed in `declarations`.</li>
                                                        <li>All selectors of directives exported from imported NgModules.</li>
                                                    </ul>
                                                </li>
                                            </ol>
                                            <p>Components, directives, and pipes must belong to exactly one module. The compiler emits an error if you try to declare the same class in more than one module. Be careful not to re-declare a class that is imported directly or indirectly from another module.</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>providers</td>
                                        <td>
                                            <p>A list of dependency-injection providers.</p>
                                            <p>Angular registers these providers with the NgModule's injector. If it is the NgModule used for bootstrapping then it is the root injector.</p>
                                            <p>These services become available for injection into any component, directive, pipe or service which is a child of this injector.</p>
                                            <p>A lazy-loaded module has its own injector which is typically a child of the application root injector.</p>
                                            <p>Lazy-loaded services are scoped to the lazy module's injector. If a lazy-loaded module also provides the UserService, any component created within that module's context (such as by router navigation) gets the local instance of the service, not the instance in the root application injector.</p>
                                            <p>Components in external modules continue to receive the instance provided by their injectors.</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>imports</td>
                                        <td>
                                            <p>A list of modules which should be folded into this module. Folded means it is as if all the imported NgModule's exported properties were declared here.</p>
                                            <p>Specifically, it is as if the list of modules whose exported components, directives, or pipes are referenced by the component templates were declared in this module.</p>
                                            <p>A component template can reference another component, directive, or pipe when the reference is declared in this module or if the imported module has exported it. For example, a component can use the NgIf and NgFor directives only if the module has imported the Angular CommonModule (perhaps indirectly by importing BrowserModule).</p>
                                            <p>You can import many standard directives from the CommonModule but some familiar directives belong to other modules. For example, you can use [(ngModel)] only after importing the Angular FormsModule.</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>exports</td>
                                        <td>
                                            <p>A list of declarations—component, directive, and pipe classes—that an importing module can use.</p>
                                            <p>Exported declarations are the module's public API. A component in another module can use this module's UserComponent if it imports this module and this module exports UserComponent.</p>
                                            <p>Declarations are private by default. If this module does not export UserComponent, then only the components within this module can use UserComponent.</p>
                                            <p>Importing a module does not automatically re-export the imported module's imports. Module 'B' can't use ngIf just because it imported module 'A' which imported CommonModule. Module 'B' must import CommonModule itself.</p>
                                            <p>A module can list another module among its exports, in which case all of that module's public components, directives, and pipes are exported.</p>
                                            <p>Re-export makes module transitivity explicit. If Module 'A' re-exports CommonModule and Module 'B' imports Module 'A', Module 'B' components can use ngIf even though 'B' itself didn't import CommonModule.</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>bootstrap</td>
                                        <td>
                                            <p>A list of components that are automatically bootstrapped.</p>
                                            <p>Usually there's only one component in this list, the root component of the application.</p>
                                            <p>Angular can launch with multiple bootstrap components, each with its own location in the host web page.</p>
                                            <p>A bootstrap component is automatically added to entryComponents.</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>entryComponents</td>
                                        <td>
                                            <p>A list of components that can be dynamically loaded into the view.</p>
                                            <p>By default, an Angular application always has at least one entry component, the root component, AppComponent. Its purpose is to serve as a point of entry into the app, that is, you bootstrap it to launch the application.</p>
                                            <p>Routed components are also entry components because they need to be loaded dynamically. The router creates them and drops them into the DOM near a < router-outlet>.</p>
                                            <p>While the bootstrapped and routed components are entry components, you don't have to add them to a module's entryComponents list, as they are added implicitly.</p>
                                            <p>Angular automatically adds components in the module's bootstrap and route definitions into the entryComponents list.</p>
                                            <p>That leaves only components bootstrapped using one of the imperative techniques, such as ViewComponentRef.createComponent() as undiscoverable.</p>
                                            <p>Dynamic component loading is not common in most applications beyond the router. If you need to dynamically load components, you must add these components to the entryComponents list yourself.</p>
                                        </td>
                                    </tr>
                                </thead>
                            </table>
                        </ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content12>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            NgModule FAQ
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content12Content>
                        <ng-container #description_12>
                            <p>NgModules help organize an application into cohesive blocks of functionality.</p>
                        </ng-container>

                        <ng-container #content12_1>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What classes should I add to the declarations array?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_1_Inner>
                                        <p>Add declarable classes—components, directives, and pipes—to a declarations list.</p>
                                        <p>Declare these classes in exactly one module of the application. Declare them in a module if they belong to that particular module.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_2>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What is a declarable?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_2_Inner>
                                        <p>Declarables are the class types—components, directives, and pipes—that you can add to a module's declarations list. They're the only classes that you can add to declarations.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_3>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What classes should I not add to declarations?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_3_Inner>
                                        <p>Add only declarable classes to an NgModule's declarations list.</p>
                                        <p>Do not declare the following:</p>
                                        <ul>
                                            <li>A class that's already declared in another module, whether an application module, @NgModule, or third-party module.</li>
                                            <li>An array of directives imported from another module. For example, don't declare FORMS_DIRECTIVES from @angular/forms because the FormsModule already declares it.</li>
                                            <li>Module classes.</li>
                                            <li>Service classes.</li>
                                            <li>Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.</li>
                                        </ul>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_4>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why list the same component in multiple NgModule properties?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_4_Inner>
                                        <p>AppComponent is often listed in both declarations and bootstrap. You might see the same component listed in declarations, exports, and entryComponents.</p>
                                        <p>While that seems redundant, these properties have different functions. Membership in one list doesn't imply membership in another list.</p>
                                        <ul>
                                            <li>AppComponent could be declared in this module but not bootstrapped.</li>
                                            <li>AppComponent could be bootstrapped in this module but declared in a different feature module.</li>
                                            <li>A component could be imported from another application module (so you can't declare it) and re-exported by this module.</li>
                                            <li>A component could be exported for inclusion in an external component's template as well as dynamically loaded in a pop-up dialog.</li>
                                        </ul>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_5>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What does "Can't bind to 'x' since it isn't a known property of 'y'" mean?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_5_Inner>
                                        <p>This error often means that you haven't declared the directive "x" or haven't imported the NgModule to which "x" belongs.</p>
                                        <p class="note">
                                            Perhaps you declared "x" in an application sub-module but forgot to export it. The "x" class isn't visible to other modules until you add it to the exports list.
                                        </p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_6>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What should I import?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_6_Inner>
                                        <p>Import NgModules whose public (exported) declarable classes you need to reference in this module's component templates.</p>
                                        <p>This always means importing CommonModule from @angular/common for access to the Angular directives such as NgIf and NgFor. You can import it directly or from another NgModule that re-exports it.</p>
                                        <p>Import FormsModule from @angular/forms if your components have [(ngModel)] two-way binding expressions.</p>
                                        <p>Import shared and feature modules when this module's components incorporate their components, directives, and pipes.</p>
                                        <p>Import BrowserModule only in the root AppModule.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_7>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Should I import BrowserModule or CommonModule?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_7_Inner>
                                        <p>The root application module, AppModule, of almost every browser application should import BrowserModule from @angular/platform-browser.</p>
                                        <p>BrowserModule provides services that are essential to launch and run a browser application.</p>
                                        <p>BrowserModule also re-exports CommonModule from @angular/common, which means that components in the AppModule also have access to the Angular directives every application needs, such as NgIf and NgFor.</p>
                                        <p>Do not import BrowserModule in any other module. Feature modules and lazy-loaded modules should import CommonModule instead. They need the common directives. They don't need to re-install the app-wide providers.</p>
                                        <p>Importing CommonModule also frees feature modules for use on any target platform, not just browsers.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_8>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What if I import the same module twice?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_8_Inner>
                                        <p>That's not a problem. When three modules all import Module 'A', Angular evaluates Module 'A' once, the first time it encounters it, and doesn't do so again.</p>
                                        <p>That's true at whatever level A appears in a hierarchy of imported NgModules. When Module 'B' imports Module 'A', Module 'C' imports 'B', and Module 'D' imports [C, B, A], then 'D' triggers the evaluation of 'C', which triggers the evaluation of 'B', which evaluates 'A'. When Angular gets to the 'B' and 'A' in 'D', they're already cached and ready to go. </p>
                                        <p>Angular doesn't like NgModules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_9>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What should I export?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_9_Inner>
                                        <p>Export declarable classes that components in other NgModules are able to reference in their templates. These are your public classes. If you don't export a declarable class, it stays private, visible only to other components declared in this NgModule.</p>
                                        <p>You can export any declarable class—components, directives, and pipes—whether it's declared in this NgModule or in an imported NgModule.</p>
                                        <p>You can re-export entire imported NgModules, which effectively re-export all of their exported classes. An NgModule can even export a module that it doesn't import.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_10>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What should I not export?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_10_Inner>
                                        <p>Don't export the following:</p>
                                        <ul>
                                            <li>Private components, directives, and pipes that you need only within components declared in this NgModule. If you don't want another NgModule to see it, don't export it.</li>
                                            <li>Non-declarable objects such as services, functions, configurations, and entity models.</li>
                                            <li>Components that are only loaded dynamically by the router or by bootstrapping. Such entry components can never be selected in another component's template. While there's no harm in exporting them, there's also no benefit.</li>
                                            <li>Pure service modules that don't have public (exported) declarations. For example, there's no point in re-exporting HttpClientModule because it doesn't export anything. Its only purpose is to add http service providers to the application as a whole.</li>
                                        </ul>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_11>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Can I re-export classes and modules?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_11_Inner>
                                        <p>Absolutely.</p>
                                        <p>NgModules are a great way to selectively aggregate classes from other NgModules and re-export them in a consolidated, convenience module.</p>
                                        <p>An NgModule can re-export entire NgModules, which effectively re-exports all of their exported classes. Angular's own BrowserModule exports a couple of NgModules like this:</p>
                                        <code-example code="
                                        exports: [CommonModule, ApplicationModule]
                                        "></code-example>
                                        <p>An NgModule can export a combination of its own declarations, selected imported classes, and imported NgModules.</p>
                                        <p>Don't bother re-exporting pure service modules. Pure service modules don't export declarable classes that another NgModule could use. For example, there's no point in re-exporting HttpClientModule because it doesn't export anything. Its only purpose is to add http service providers to the application as a whole.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_12>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What is the forRoot() method?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_12_Inner>
                                        <p>The forRoot() static method is a convention that makes it easy for developers to configure services and providers that are intended to be singletons. A good example of forRoot() is the RouterModule.forRoot() method.</p>
                                        <p>Applications pass a Routes array to RouterModule.forRoot() in order to configure the app-wide Router service with routes. RouterModule.forRoot() returns a ModuleWithProviders. You add that result to the imports list of the root AppModule.</p>
                                        <p>Only call and import a forRoot() result in the root application module, AppModule. Avoid importing it in any other module, particularly in a lazy-loaded module. For more information on forRoot() see the forRoot() pattern section of the Singleton Services guide.</p>
                                        <p class="note">
                                            Note: the `forRoot()` import can be used in a module other than `AppModule`. Importantly, `forRoot()` should only be called once, and the module that imports the `forRoot()` needs to be available to the root `ModuleInjector`. For more information, refer to the guide on [Hierarchical injectors](guide/hierarchical-dependency-injection#moduleinjector).
                                        </p>
                                        <p>For a service, instead of using forRoot(), specify providedIn: 'root' on the service's @Injectable() decorator, which makes the service automatically available to the whole application and thus singleton by default.</p>
                                        <p>RouterModule also offers a forChild() static method for configuring the routes of lazy-loaded modules.</p>
                                        <p>forRoot() and forChild() are conventional names for methods that configure services in root and feature modules respectively.</p>
                                        <p>Follow this convention when you write similar modules with configurable service providers.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_13>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why is a service provided in a feature module visible everywhere?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_13_Inner>
                                        <p>Providers listed in the @NgModule.providers of a bootstrapped module have application scope. Adding a service provider to @NgModule.providers effectively publishes the service to the entire application.</p>
                                        <p>When you import an NgModule, Angular adds the module's service providers (the contents of its providers list) to the application root injector.</p>
                                        <p>This makes the provider visible to every class in the application that knows the provider's lookup token, or name.</p>
                                        <p>Extensibility through NgModule imports is a primary goal of the NgModule system. Merging NgModule providers into the application injector makes it easy for a module library to enrich the entire application with new services. By adding the HttpClientModule once, every application component can make HTTP requests.</p>
                                        <p>However, this might feel like an unwelcome surprise if you expect the module's services to be visible only to the components declared by that feature module. If the HeroModule provides the HeroService and the root AppModule imports HeroModule, any class that knows the HeroService type can inject that service, not just the classes declared in the HeroModule.</p>
                                        <p>To limit access to a service, consider lazy loading the NgModule that provides that service. See How do I restrict service scope to a module? for more information.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_14>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why is a service provided in a lazy-loaded module visible only to that module?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_14_Inner>
                                        <p>Unlike providers of the modules loaded at launch, providers of lazy-loaded modules are module-scoped.</p>
                                        <p>When the Angular router lazy-loads a module, it creates a new execution context. That context has its own injector, which is a direct child of the application injector.</p>
                                        <p>The router adds the lazy module's providers and the providers of its imported NgModules to this child injector.</p>
                                        <p>These providers are insulated from changes to application providers with the same lookup token. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_15>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What if two modules provide the same service?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_15_Inner>
                                        <p>When two imported modules, loaded at the same time, list a provider with the same token, the second module's provider "wins". That's because both providers are added to the same injector.</p>
                                        <p>When Angular looks to inject a service for that token, it creates and delivers the instance created by the second provider.</p>
                                        <p>Every class that injects this service gets the instance created by the second provider. Even classes declared within the first module get the instance created by the second provider.</p>
                                        <p>If NgModule A provides a service for token 'X' and imports an NgModule B that also provides a service for token 'X', then NgModule A's service definition "wins".</p>
                                        <p>The service provided by the root AppModule takes precedence over services provided by imported NgModules. The AppModule always wins.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_16>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            How do I restrict service scope to a module?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_16_Inner>
                                        <p>When a module is loaded at application launch, its @NgModule.providers have application-wide scope; that is, they are available for injection throughout the application.</p>
                                        <p>Imported providers are easily replaced by providers from another imported NgModule. Such replacement might be by design. It could be unintentional and have adverse consequences.</p>
                                        <p>As a general rule, import modules with providers exactly once, preferably in the application's root module. That's also usually the best place to configure, wrap, and override them.</p>
                                        <p>Suppose a module requires a customized HttpBackend that adds a special header for all Http requests. If another module elsewhere in the application also customizes HttpBackend or merely imports the HttpClientModule, it could override this module's HttpBackend provider, losing the special header. The server will reject http requests from this module.</p>
                                        <p>To avoid this problem, import the HttpClientModule only in the AppModule, the application root module.</p>
                                        <p>If you must guard against this kind of "provider corruption", don't rely on a launch-time module's providers.</p>
                                        <p>Load the module lazily if you can. Angular gives a lazy-loaded module its own child injector. The module's providers are visible only within the component tree created with this injector.</p>
                                        <p>If you must load the module eagerly, when the application starts, provide the service in a component instead.</p>
                                        <p>Continuing with the same example, suppose the components of a module truly require a private, custom HttpBackend.</p>
                                        <p>Create a "top component" that acts as the root for all of the module's components. Add the custom HttpBackend provider to the top component's providers list rather than the module's providers. Recall that Angular creates a child injector for each component instance and populates the injector with the component's own providers.</p>
                                        <p>When a child of this component asks for the HttpBackend service, Angular provides the local HttpBackend service, not the version provided in the application root injector. Child components make proper HTTP requests no matter what other modules do to HttpBackend.</p>
                                        <p>Be sure to create module components as children of this module's top component.</p>
                                        <p>You can embed the child components in the top component's template. Alternatively, make the top component a routing host by giving it a < router-outlet>. Define child routes and let the router load module components into that outlet.</p>
                                        <p>Though you can limit access to a service by providing it in a lazy loaded module or providing it in a component, providing services in a component can lead to multiple instances of those services. Thus, the lazy loading is preferable.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_17>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Should I add application-wide providers to the root AppModule or the root AppComponent?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_17_Inner>
                                        <p>Define application-wide providers by specifying providedIn: 'root' on its @Injectable() decorator (in the case of services) or at InjectionToken construction (in the case where tokens are provided). Providers that are created this way automatically are made available to the entire application and don't need to be listed in any module.</p>
                                        <p>If a provider cannot be configured in this way (perhaps because it has no sensible default value), then register application-wide providers in the root AppModule, not in the AppComponent.</p>
                                        <p>Lazy-loaded modules and their components can inject AppModule services; they can't inject AppComponent services.</p>
                                        <p>Register a service in AppComponent providers only if the service must be hidden from components outside the AppComponent tree. This is a rare use case.</p>
                                        <p>More generally, prefer registering providers in NgModules to registering in components.</p>

                                        <br>
                                        <h3>Discussion</h3>
                                        <p>Angular registers all startup module providers with the application root injector. The services that root injector providers create have application scope, which means they are available to the entire application.</p>
                                        <p>Certain services, such as the Router, only work when you register them in the application root injector.</p>
                                        <p>By contrast, Angular registers AppComponent providers with the AppComponent's own injector. AppComponent services are available only to that component and its component tree. They have component scope.</p>
                                        <p>The AppComponent's injector is a child of the root injector, one down in the injector hierarchy. For applications that don't use the router, that's almost the entire application. But in routed applications, routing operates at the root level where AppComponent services don't exist. This means that lazy-loaded modules can't reach them.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_18>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Should I add other providers to a module or a component?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_18_Inner>
                                        <p>Providers should be configured using @Injectable syntax. If possible, they should be provided in the application root (providedIn: 'root'). Services that are configured this way are lazily loaded if they are only used from a lazily loaded context.</p>
                                        <p>If it's the consumer's decision whether a provider is available application-wide or not, then register providers in modules (@NgModule.providers) instead of registering in components (@Component.providers).</p>
                                        <p>Register a provider with a component when you must limit the scope of a service instance to that component and its component tree. Apply the same reasoning to registering a provider with a directive.</p>
                                        <p>For example, an editing component that needs a private copy of a caching service should register the service with the component. Then each new instance of the component gets its own cached service instance. The changes that editor makes in its service don't touch the instances elsewhere in the application.</p>
                                        <p>Always register application-wide services with the root AppModule, not the root AppComponent.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_19>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why is it bad if a shared module provides a service to a lazy-loaded module?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_19_Inner>
                                        <h3>The eagerly loaded scenario</h3>
                                        <p>When an eagerly loaded module provides a service, for example a UserService, that service is available application-wide. If the root module provides UserService and imports another module that provides the same UserService, Angular registers one of them in the root application injector</p>
                                        <p>Then, when some component injects UserService, Angular finds it in the application root injector, and delivers the app-wide singleton service. No problem.</p>

                                        <br>
                                        <h3>The lazy loaded scenario</h3>
                                        <p>Now consider a lazy loaded module that also provides a service called UserService.</p>
                                        <p>When the router lazy loads a module, it creates a child injector and registers the UserService provider with that child injector. The child injector is not the root injector.</p>
                                        <p>When Angular creates a lazy component for that module and injects UserService, it finds a UserService provider in the lazy module's child injector and creates a new instance of the UserService. This is an entirely different UserService instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p>
                                        <p>This scenario causes your application to create a new instance every time, instead of using the singleton.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_20>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why does lazy loading create a child injector?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_20_Inner>
                                        <p>Angular adds @NgModule.providers to the application root injector, unless the NgModule is lazy-loaded. For a lazy-loaded NgModule, Angular creates a child injector and adds the module's providers to the child injector.</p>
                                        <p>This means that an NgModule behaves differently depending on whether it's loaded during application start or lazy-loaded later. Neglecting that difference can lead to adverse consequences.</p>
                                        <p>Why doesn't Angular add lazy-loaded providers to the application root injector as it does for eagerly loaded NgModules?</p>
                                        <p>The answer is grounded in a fundamental characteristic of the Angular dependency-injection system. An injector can add providers until it's first used. Once an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.</p>
                                        <p>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules before creating its first component and injecting any of the provided services. Once the application begins, the application root injector is closed to new providers.</p>
                                        <p>Time passes and application logic triggers lazy loading of an NgModule. Angular must add the lazy-loaded module's providers to an injector somewhere. It can't add them to the application root injector because that injector is closed to new providers. So Angular creates a new child injector for the lazy-loaded module context.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_21>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            How can I tell if an NgModule or service was previously loaded?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_21_Inner>
                                        <p>Some NgModules and their services should be loaded only once by the root AppModule. Importing the module a second time by lazy loading a module could produce errant behavior that may be difficult to detect and diagnose.</p>
                                        <p>To prevent this issue, write a constructor that attempts to inject the module or service from the root application injector. If the injection succeeds, the class has been loaded a second time. You can throw an error or take other remedial action.</p>
                                        <p>Certain NgModules, such as BrowserModule, implement such a guard. Here is a custom constructor for an NgModule called GreetingModule.</p>
                                        <code-example code="
                                        constructor(@Optional() @SkipSelf() parentModule?: GreetingModule) {
                                            if (parentModule) {
                                              throw new Error(
                                                'GreetingModule is already loaded. Import it in the AppModule only');
                                            }
                                          }
                                        "></code-example>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_22>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What is an entry component?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_22_Inner>
                                        <p>An entry component is any component that Angular loads imperatively by type.</p>
                                        <p>A component loaded declaratively by way of its selector is not an entry component.</p>
                                        <p>Angular loads a component declaratively when using the component's selector to locate the element in the template. Angular then creates the HTML representation of the component and inserts it into the DOM at the selected element. These aren't entry components.</p>
                                        <p>The bootstrapped root AppComponent is an entry component. True, its selector matches an element tag in index.html. But index.html isn't a component template and the AppComponent selector doesn't match an element in any component template.</p>
                                        <p>Components in route definitions are also entry components. A route definition refers to a component by its type. The router ignores a routed component's selector, if it even has one, and loads the component dynamically into a RouterOutlet.</p>
                                        <p>For more information, see Entry Components.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_23>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What's the difference between a bootstrap component and an entry component?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_23_Inner>
                                        <p>A bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process (application launch). Other entry components are loaded dynamically by other means, such as with the router.</p>
                                        <p>The @NgModule.bootstrap property tells the compiler that this is an entry component and it should generate code to bootstrap the application with this component.</p>
                                        <p>There's no need to list a component in both the bootstrap and entryComponents lists, although doing so is harmless.</p>
                                        <p>For more information, see Entry Components.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_24>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            When do I add components to entryComponents?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_24_Inner>
                                        <p>Most application developers won't need to add components to the entryComponents.</p>
                                        <p>Angular adds certain components to entry components automatically. Components listed in @NgModule.bootstrap are added automatically. Components referenced in router configuration are added automatically. These two mechanisms account for almost all entry components.</p>
                                        <p>If your application happens to bootstrap or dynamically load a component by type in some other manner, you must add it to entryComponents explicitly.</p>
                                        <p>Although it's harmless to add components to this list, it's best to add only the components that are truly entry components. Don't include components that are referenced in the templates of other components.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_25>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            Why does Angular need entryComponents?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_25_Inner>
                                        <p>The reason is tree shaking. For production applications you want to load the smallest, fastest code possible. The code should contain only the classes that you actually need. It should exclude a component that's never used, whether or not that component is declared.</p>
                                        <p>In fact, many libraries declare and export components you'll never use. If you don't reference them, the tree shaker drops these components from the final code package.</p>
                                        <p>If the Angular compiler generated code for every declared component, it would defeat the purpose of the tree shaker.</p>
                                        <p>Instead, the compiler adopts a recursive strategy that generates code only for the components you use.</p>
                                        <p>The compiler starts with the entry components, then it generates code for the declared components it finds in an entry component's template, then for the declared components it discovers in the templates of previously compiled components, and so on. At the end of the process, the compiler has generated code for every entry component and every component reachable from an entry component.</p>
                                        <p>If a component isn't an entry component or wasn't found in a template, the compiler omits it.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_26>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What kinds of modules should I have and how should I use them?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_26_Inner>
                                        <p>Every application is different. Developers have various levels of experience and comfort with the available choices. Some suggestions and guidelines appear to have wide appeal.</p>

                                        <br>
                                        <h3>SharedModule</h3>
                                        <p>SharedModule is a conventional name for an NgModule with the components, directives, and pipes that you use everywhere in your application. This module should consist entirely of declarations, most of them exported.</p>
                                        <p>The SharedModule may re-export other widget modules, such as CommonModule, FormsModule, and NgModules with the UI controls that you use most widely.</p>
                                        <p>The SharedModule should not have providers for reasons explained previously. Nor should any of its imported or re-exported modules have providers.</p>
                                        <p>Import the SharedModule in your feature modules, both those loaded when the application starts and those you lazy load later.</p>

                                        <br>
                                        <h3>Feature Modules</h3>
                                        <p>Feature modules are modules you create around specific application business domains, user workflows, and utility collections. They support your application by containing a particular feature, such as routes, services, widgets, etc. To conceptualize what a feature module might be in your app, consider that if you would put the files related to a certain functionality, like a search, in one folder, that the contents of that folder would be a feature module that you might call your SearchModule. It would contain all of the components, routing, and templates that would make up the search functionality.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_27>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What's the difference between NgModules and JavaScript Modules?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_27_Inner>
                                        <p>In an Angular app, NgModules and JavaScript modules work together.</p>
                                        <p>In modern JavaScript, every file is a module (see the Modules page of the Exploring ES6 website). Within each file you write an export statement to make parts of the module public.</p>
                                        <p>An Angular NgModule is a class with the @NgModule decorator—JavaScript modules don't have to have the @NgModule decorator. Angular's NgModule has imports and exports and they serve a similar purpose.</p>
                                        <p>You import other NgModules so you can use their exported classes in component templates. You export this NgModule's classes so they can be imported and used by components of other NgModules.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_28>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            How does Angular find components, directives, and pipes in a template? What is a template reference?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_28_Inner>
                                        <p>The Angular compiler looks inside component templates for other components, directives, and pipes. When it finds one, that's a template reference.</p>
                                        <p>The Angular compiler finds a component or directive in a template when it can match the selector of that component or directive to some HTML in that template.</p>
                                        <p>The compiler finds a pipe if the pipe's name appears within the pipe syntax of the template HTML.</p>
                                        <p>Angular only matches selectors and pipe names for classes that are declared by this module or exported by a module that this module imports.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content12_29>
                            <mat-accordion>
                                <mat-expansion-panel>
                                    <mat-expansion-panel-header>
                                        <mat-panel-title>
                                            What is the Angular compiler?
                                        </mat-panel-title>
                                    </mat-expansion-panel-header>
                
                                    <ng-container #content12_29_Inner>
                                        <p>The Angular compiler converts the application code you write into highly performant JavaScript code. The @NgModule metadata plays an important role in guiding the compilation process.</p>
                                        <p>The code you write isn't immediately executable. For example, components have templates that contain custom elements, attribute directives, Angular binding declarations, and some peculiar syntax that clearly isn't native HTML.</p>
                                        <p>The Angular compiler reads the template markup, combines it with the corresponding component class code, and emits component factories.</p>
                                        <p>A component factory creates a pure, 100% JavaScript representation of the component that incorporates everything described in its @Component metadata: the HTML, the binding instructions, the attached styles.</p>
                                        <p>Because directives and pipes appear in component templates, the Angular compiler incorporates them into compiled component code too.</p>
                                        <p>@NgModule metadata tells the Angular compiler what components to compile for this module and how to link this module with other modules.</p>
                                    </ng-container>
                                </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>
        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #observableRxjsTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Observable & RxJS
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #observableRxjsContent>
            <ng-container #description>
            </ng-container>

            <ng-container #content1>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Using observables to pass values
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content1Content>
                        <ng-container #description_1>
                            <p>Observables provide support for passing messages between parts of your application. They are used frequently in Angular and are a technique for event handling, asynchronous programming, and handling multiple values.</p>
                            <p>The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of state changes. This pattern is similar (but not identical) to the publish/subscribe design pattern.</p>
                            <p>Observables are declarative—that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.</p>
                            <p>An observable can deliver multiple values of any type—literals, messages, or events, depending on the context. The API for receiving values is the same whether the values are delivered synchronously or asynchronously. Because setup and teardown logic are both handled by the observable, your application code only needs to worry about subscribing to consume values, and when done, unsubscribing. Whether the stream was keystrokes, an HTTP response, or an interval timer, the interface for listening to values and stopping listening is the same.</p>
                            <p>Because of these advantages, observables are used extensively within Angular, and for application development as well. </p>
                        </ng-container>

                        <ng-container #content1_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Basic usage and terms
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_1>
                                    <ng-container #description_1_1>
                                        <p>As a publisher, you create an Observable instance that defines a subscriber function. This is the function that is executed when a consumer calls the subscribe() method. The subscriber function defines how to obtain or generate values or messages to be published.</p>
                                        <p>To execute the observable you have created and begin receiving notifications, you call its subscribe() method, passing an observer. This is a JavaScript object that defines the handlers for the notifications you receive. The subscribe() call returns a Subscription object that has an unsubscribe() method, which you call to stop receiving notifications.</p>
                                        <p>Here's an example that demonstrates the basic usage model by showing how an observable could be used to provide geolocation updates.</p>
                                        <code-example code="
                                        // Create an Observable that will start listening to geolocation updates
                                        // when a consumer subscribes.
                                        const locations = new Observable((observer) => {
                                          let watchId: number;
                                        
                                          // Simple geolocation API check provides values to publish
                                          if ('geolocation' in navigator) {
                                            watchId = navigator.geolocation.watchPosition((position: GeolocationPosition) => {
                                              observer.next(position);
                                            }, (error: GeolocationPositionError) => {
                                              observer.error(error);
                                            });
                                          } else {
                                            observer.error('Geolocation not available');
                                          }
                                        
                                          // When the consumer unsubscribes, clean up data ready for next subscription.
                                          return {
                                            unsubscribe() {
                                              navigator.geolocation.clearWatch(watchId);
                                            }
                                          };
                                        });
                                        
                                        // Call subscribe() to start listening for updates.
                                        const locationsSubscription = locations.subscribe({
                                          next(position) {
                                            console.log('Current Position: ', position);
                                          },
                                          error(msg) {
                                            console.log('Error Getting Location: ', msg);
                                          }
                                        });
                                        
                                        // Stop listening for location after 10 seconds
                                        setTimeout(() => {
                                          locationsSubscription.unsubscribe();
                                        }, 10000);
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
            
                        <ng-container #content2_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Defining observers
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_1>
                                    <ng-container #description_2_1>
                                        <p>A handler for receiving observable notifications implements the Observer interface. It is an object that defines callback methods to handle the three types of notifications that an observable can send:</p>
                                        <table>
                                            <thead>
                                                <tr>
                                                    <td>NOTIFICATION TYPE</td>
                                                    <td>DESCRIPTION</td>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>next</td>
                                                    <td>Required. A handler for each delivered value. Called zero or more times after execution starts.</td>
                                                </tr>
                                                <tr>
                                                    <td>error</td>
                                                    <td>Optional. A handler for an error notification. An error halts execution of the observable instance.</td>
                                                </tr>
                                                <tr>
                                                    <td>complete</td>
                                                    <td>Optional. A handler for the execution-complete notification. Delayed values can continue to be delivered to the next handler after execution is complete.</td>
                                                </tr>
                                            </tbody>
                                        </table>
            
                                        <p>An observer object can define any combination of these handlers. If you don't supply a handler for a notification type, the observer ignores notifications of that type.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
            
                        <ng-container #content3_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Subscribing
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content3Content_1>
                                    <ng-container #description_3_1>
                                        <p>An Observable instance begins publishing values only when someone subscribes to it. You subscribe by calling the subscribe() method of the instance, passing an observer object to receive the notifications.</p>
                                        <span class="note">
                                            <p>In order to show how subscribing works, we need to create a new observable. There is a constructor that you use to create new instances, but for illustration, we can use some methods from the RxJS library that create simple observables of frequently used types:</p>
                                            <ul>
                                                <li>of(...items)—Returns an Observable instance that synchronously delivers the values provided as arguments.</li>
                                                <li>from(iterable)—Converts its argument to an Observable instance. This method is commonly used to convert an array to an observable.</li>
                                            </ul>
                                        </span>
                                        <p>Here's an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console:</p>
                                        <code-example code="
                                        // Create simple observable that emits three values
                                        const myObservable = of(1, 2, 3);
                                        
                                        // Create observer object
                                        const myObserver = {
                                          next: (x: number) => console.log('Observer got a next value: ' + x),
                                          error: (err: Error) => console.error('Observer got an error: ' + err),
                                          complete: () => console.log('Observer got a complete notification'),
                                        };
                                        
                                        // Execute with the observer object
                                        myObservable.subscribe(myObserver);
                                        
                                        // Logs:
                                        // Observer got a next value: 1
                                        // Observer got a next value: 2
                                        // Observer got a next value: 3
                                        // Observer got a complete notification
                                        "></code-example>
                                        <p>Alternatively, the subscribe() method can accept callback function definitions in line, for next, error, and complete handlers. For example, the following subscribe() call is the same as the one that specifies the predefined observer:</p>
                                        <code-example code="
                                        myObservable.subscribe(
                                            x => console.log('Observer got a next value: ' + x),
                                            err => console.error('Observer got an error: ' + err),
                                            () => console.log('Observer got a complete notification')
                                          );
                                        "></code-example>
            
                                        <p>In either case, a next handler is required. The error and complete handlers are optional.</p>
                                        <p>Note that a next() function could receive, for instance, message strings, or event objects, numeric values, or structures, depending on context. As a general term, we refer to data published by an observable as a stream. Any type of value can be represented with an observable, and the values are published as a stream.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
            
                        <ng-container #content4_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Creating observables
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content4Content_1>
                                    <ng-container #description_4_1>
                                        <p>Use the Observable constructor to create an observable stream of any type. The constructor takes as its argument the subscriber function to run when the observable’s subscribe() method executes. A subscriber function receives an Observer object, and can publish values to the observer's next() method.</p>
                                        <p>For example, to create an observable equivalent to the of(1, 2, 3) above, you could do something like this:</p>
                                        <code-example code="
                                        // This function runs when subscribe() is called
                                        function sequenceSubscriber(observer: Observer<number>) {
                                          // synchronously deliver 1, 2, and 3, then complete
                                          observer.next(1);
                                          observer.next(2);
                                          observer.next(3);
                                          observer.complete();
                                        
                                          // unsubscribe function doesn't need to do anything in this
                                          // because values are delivered synchronously
                                          return {unsubscribe() {}};
                                        }
                                        
                                        // Create a new Observable that will deliver the above sequence
                                        const sequence = new Observable(sequenceSubscriber);
                                        
                                        // execute the Observable and print the result of each notification
                                        sequence.subscribe({
                                          next(num) { console.log(num); },
                                          complete() { console.log('Finished sequence'); }
                                        });
                                        
                                        // Logs:
                                        // 1
                                        // 2
                                        // 3
                                        // Finished sequence
                                        "></code-example>
            
                                        <p>To take this example a little further, we can create an observable that publishes events. In this example, the subscriber function is defined inline.</p>
                                        <code-example code="
                                        function fromEvent<T extends keyof HTMLElementEventMap>(target: HTMLElement, eventName: T) {
                                            return new Observable<HTMLElementEventMap[T]>((observer) => {
                                              const handler = (e: HTMLElementEventMap[T]) => observer.next(e);
                                          
                                              // Add the event handler to the target
                                              target.addEventListener(eventName, handler);
                                          
                                              return () => {
                                                // Detach the event handler from the target
                                                target.removeEventListener(eventName, handler);
                                              };
                                            });
                                          }
                                        "></code-example>
                                        <p>Now you can use this function to create an observable that publishes keydown events:</p>
                                        <code-example code="
                                        const ESC_KEY = 27;
                                        const nameInput = document.getElementById('name') as HTMLInputElement;
                                        
                                        const subscription = fromEvent(nameInput, 'keydown').subscribe((e: KeyboardEvent) => {
                                          if (e.keyCode === ESC_KEY) {
                                            nameInput.value = '';
                                          }
                                        });
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
            
                        <ng-container #content5_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Multicasting
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content5Content_1>
                                    <ng-container #description_5_1>
                                        <p>A typical observable creates a new, independent execution for each subscribed observer. When an observer subscribes, the observable wires up an event handler and delivers values to that observer. When a second observer subscribes, the observable then wires up a new event handler and delivers values to that second observer in a separate execution.</p>
                                        <p>Sometimes, instead of starting an independent execution for each subscriber, you want each subscription to get the same values—even if values have already started emitting. This might be the case with something like an observable of clicks on the document object.</p>
                                        <p>Multicasting is the practice of broadcasting to a list of multiple subscribers in a single execution. With a multicasting observable, you don't register multiple listeners on the document, but instead re-use the first listener and send values out to each subscriber.</p>
                                        <p>When creating an observable you should determine how you want that observable to be used and whether or not you want to multicast its values.</p>
                                        <p>Let’s look at an example that counts from 1 to 3, with a one-second delay after each number emitted.</p>
                                        <code-example code="
                                        function sequenceSubscriber(observer: Observer<number>) {
                                            const seq = [1, 2, 3];
                                            let timeoutId: any;
                                          
                                            // Will run through an array of numbers, emitting one value
                                            // per second until it gets to the end of the array.
                                            function doInSequence(arr: number[], idx: number) {
                                              timeoutId = setTimeout(() => {
                                                observer.next(arr[idx]);
                                                if (idx === arr.length - 1) {
                                                  observer.complete();
                                                } else {
                                                  doInSequence(arr, ++idx);
                                                }
                                              }, 1000);
                                            }
                                          
                                            doInSequence(seq, 0);
                                          
                                            // Unsubscribe should clear the timeout to stop execution
                                            return {
                                              unsubscribe() {
                                                clearTimeout(timeoutId);
                                              }
                                            };
                                          }
                                          
                                          // Create a new Observable that will deliver the above sequence
                                          const sequence = new Observable(sequenceSubscriber);
                                          
                                          sequence.subscribe({
                                            next(num) { console.log(num); },
                                            complete() { console.log('Finished sequence'); }
                                          });
                                          
                                          // Logs:
                                          // (at 1 second): 1
                                          // (at 2 seconds): 2
                                          // (at 3 seconds): 3
                                          // (at 3 seconds): Finished sequence
                                        "></code-example>
                                        <p>Notice that if you subscribe twice, there will be two separate streams, each emitting values every second. It looks something like this:</p>
                                        <code-example code="
                                        // Subscribe starts the clock, and will emit after 1 second
                                        sequence.subscribe({
                                          next(num) { console.log('1st subscribe: ' + num); },
                                          complete() { console.log('1st sequence finished.'); }
                                        });
                                        
                                        // After 1/2 second, subscribe again.
                                        setTimeout(() => {
                                          sequence.subscribe({
                                            next(num) { console.log('2nd subscribe: ' + num); },
                                            complete() { console.log('2nd sequence finished.'); }
                                          });
                                        }, 500);
                                        
                                        // Logs:
                                        // (at 1 second): 1st subscribe: 1
                                        // (at 1.5 seconds): 2nd subscribe: 1
                                        // (at 2 seconds): 1st subscribe: 2
                                        // (at 2.5 seconds): 2nd subscribe: 2
                                        // (at 3 seconds): 1st subscribe: 3
                                        // (at 3 seconds): 1st sequence finished
                                        // (at 3.5 seconds): 2nd subscribe: 3
                                        // (at 3.5 seconds): 2nd sequence finished
                                        "></code-example>
                                        <p>Changing the observable to be multicasting could look something like this:</p>
                                        <code-example code="
                                        function multicastSequenceSubscriber() {
                                            const seq = [1, 2, 3];
                                            // Keep track of each observer (one for every active subscription)
                                            const observers: Observer<unknown>[] = [];
                                            // Still a single timeoutId because there will only ever be one
                                            // set of values being generated, multicasted to each subscriber
                                            let timeoutId: any;
                                          
                                            // Return the subscriber function (runs when subscribe()
                                            // function is invoked)
                                            return (observer: Observer<unknown>) => {
                                              observers.push(observer);
                                              // When this is the first subscription, start the sequence
                                              if (observers.length === 1) {
                                                const multicastObserver: Observer<number> = {
                                                  next(val) {
                                                    // Iterate through observers and notify all subscriptions
                                                    observers.forEach(obs => obs.next(val));
                                                  },
                                                  error() { /* Handle the error... */ },
                                                  complete() {
                                                    // Notify all complete callbacks
                                                    observers.slice(0).forEach(obs => obs.complete());
                                                  }
                                                };
                                                doSequence(multicastObserver, seq, 0);
                                              }
                                          
                                              return {
                                                unsubscribe() {
                                                  // Remove from the observers array so it's no longer notified
                                                  observers.splice(observers.indexOf(observer), 1);
                                                  // If there's no more listeners, do cleanup
                                                  if (observers.length === 0) {
                                                    clearTimeout(timeoutId);
                                                  }
                                                }
                                              };
                                          
                                              // Run through an array of numbers, emitting one value
                                              // per second until it gets to the end of the array.
                                              function doSequence(sequenceObserver: Observer<number>, arr: number[], idx: number) {
                                                timeoutId = setTimeout(() => {
                                                  console.log('Emitting ' + arr[idx]);
                                                  sequenceObserver.next(arr[idx]);
                                                  if (idx === arr.length - 1) {
                                                    sequenceObserver.complete();
                                                  } else {
                                                    doSequence(sequenceObserver, arr, ++idx);
                                                  }
                                                }, 1000);
                                              }
                                            };
                                          }
                                          
                                          // Create a new Observable that will deliver the above sequence
                                          const multicastSequence = new Observable(multicastSequenceSubscriber());
                                          
                                          // Subscribe starts the clock, and begins to emit after 1 second
                                          multicastSequence.subscribe({
                                            next(num) { console.log('1st subscribe: ' + num); },
                                            complete() { console.log('1st sequence finished.'); }
                                          });
                                          
                                          // After 1 1/2 seconds, subscribe again (should 'miss' the first value).
                                          setTimeout(() => {
                                            multicastSequence.subscribe({
                                              next(num) { console.log('2nd subscribe: ' + num); },
                                              complete() { console.log('2nd sequence finished.'); }
                                            });
                                          }, 1500);
                                          
                                          // Logs:
                                          // (at 1 second): Emitting 1
                                          // (at 1 second): 1st subscribe: 1
                                          // (at 2 seconds): Emitting 2
                                          // (at 2 seconds): 1st subscribe: 2
                                          // (at 2 seconds): 2nd subscribe: 2
                                          // (at 3 seconds): Emitting 3
                                          // (at 3 seconds): 1st subscribe: 3
                                          // (at 3 seconds): 1st sequence finished
                                          // (at 3 seconds): 2nd subscribe: 3
                                          // (at 3 seconds): 2nd sequence finished
                                        "></code-example>
                                        <p class="note">Multicasting observables take a bit more setup, but they can be useful for certain applications. Later we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
            
                        <ng-container #content6_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Error handling
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content6Content_1>
                                    <ng-container #description_6_1>
                                        <p>Because observables produce values asynchronously, try/catch will not effectively catch errors. Instead, you handle errors by specifying an error callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values. An observable can either produce values (calling the next callback), or it can complete, calling either the complete or error callback.</p>
                                        <code-example code="
                                        myObservable.subscribe({
                                            next(num) { console.log('Next num: ' + num)},
                                            error(err) { console.log('Received an error: ' + err)}
                                          });
                                        "></code-example>
                                        <p>Error handling (and specifically recovering from an error) is covered in more detail in a later section.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>
                      </ng-container>
                    </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            The RxJS library
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content2Content>
                        <ng-container #description_2>
                            <p>Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (Wikipedia). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code.</p>
                            <p>RxJS provides an implementation of the Observable type, which is needed until the type becomes part of the language and until browsers support it. The library also provides utility functions for creating and working with observables. These utility functions can be used for:</p>
                            <ul>
                                <li>Converting existing code for async operations into observables</li>
                                <li>Iterating through the values in a stream</li>
                                <li>Mapping values to different types</li>
                                <li>Filtering streams</li>
                                <li>Composing multiple streams</li>
                            </ul>
                        </ng-container>

                        <ng-container #content2_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Observable creation functions
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_1>
                                    <ng-container #description_2_1>
                                        <p>RxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, and promises. For example:</p>
                                        <code-example code="
                                        import { from, Observable } from 'rxjs';

                                        // Create an Observable out of a promise
                                        const data = from(fetch('/api/endpoint'));
                                        // Subscribe to begin listening for async result
                                        data.subscribe({
                                          next(response) { console.log(response); },
                                          error(err) { console.error('Error: ' + err); },
                                          complete() { console.log('Completed'); }
                                        });
                                        "></code-example>

                                        <code-example code="
                                        import { interval } from 'rxjs';

                                        // Create an Observable that will publish a value on an interval
                                        const secondsCounter = interval(1000);
                                        // Subscribe to begin publishing values
                                        const subscription = secondsCounter.subscribe(n =>
                                          console.log(`It's been ${n + 1} seconds since subscribing!`));
                                        "></code-example>

                                        <code-example code="
                                        import { fromEvent } from 'rxjs';

                                        const el = document.getElementById('my-element')!;
                                        
                                        // Create an Observable that will publish mouse movements
                                        const mouseMoves = fromEvent<MouseEvent>(el, 'mousemove');
                                        
                                        // Subscribe to start listening for mouse-move events
                                        const subscription = mouseMoves.subscribe(evt => {
                                          // Log coords of mouse movements
                                          console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);
                                        
                                          // When the mouse is over the upper-left of the screen,
                                          // unsubscribe to stop listening for mouse movements
                                          if (evt.clientX < 40 && evt.clientY < 40) {
                                            subscription.unsubscribe();
                                          }
                                        });
                                        "></code-example>

                                        <code-example code="
                                        import { Observable } from 'rxjs';
                                        import { ajax } from 'rxjs/ajax';
                                      
                                      // Create an Observable that will create an AJAX request
                                        const apiData = ajax('/api/data');
                                        // Subscribe to create the request
                                        apiData.subscribe(res => console.log(res.status, res.response));
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_2>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Operators
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_2>
                                    <ng-container #description_2_2>
                                        <p>Operators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as map(), filter(), concat(), and flatMap().</p>
                                        <p>Operators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable’s emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:</p>
                                        <code-example code="
                                        import { of } from 'rxjs';
                                        import { map } from 'rxjs/operators';
                                        
                                        const nums = of(1, 2, 3);
                                        
                                        const squareValues = map((val: number) => val * val);
                                        const squaredNums = squareValues(nums);
                                        
                                        squaredNums.subscribe(x => console.log(x));
                                        
                                        // Logs
                                        // 1
                                        // 4
                                        // 9
                                        "></code-example>
                                        <p>You can use pipes to link operators together. Pipes let you combine multiple functions into a single function. The pipe() function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.</p>
                                        <p>A set of operators applied to an observable is a recipe—that is, a set of instructions for producing the values you’re interested in. By itself, the recipe doesn’t do anything. You need to call subscribe() to produce a result through the recipe.</p>
                                        <p>Here’s an example:</p>
                                        <code-example code="
                                        import { of, pipe } from 'rxjs';
                                        import { filter, map } from 'rxjs/operators';
                                        
                                        const nums = of(1, 2, 3, 4, 5);
                                        
                                        // Create a function that accepts an Observable.
                                        const squareOddVals = pipe(
                                          filter((n: number) => n % 2 !== 0),
                                          map(n => n * n)
                                        );
                                        
                                        // Create an Observable that will run the filter and map functions
                                        const squareOdd = squareOddVals(nums);
                                        
                                        // Subscribe to run the combined functions
                                        squareOdd.subscribe(x => console.log(x));
                                        "></code-example>

                                        <p>The pipe() function is also a method on the RxJS Observable, so you use this shorter form to define the same operation:</p>

                                        <code-example code="
                                        import { of } from 'rxjs';
                                        import { filter, map } from 'rxjs/operators';
                                        
                                        const squareOdd = of(1, 2, 3, 4, 5)
                                          .pipe(
                                            filter(n => n % 2 !== 0),
                                            map(n => n * n)
                                          );
                                        
                                        // Subscribe to get values
                                        squareOdd.subscribe(x => console.log(x));
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_3>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Common operators
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_3>
                                    <ng-container #description_2_3>
                                        <p>RxJS provides many operators, but only a handful are used frequently. For a list of operators and usage samples</p>
                                        <p class="note">
                                            Note that, for Angular applications, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.
                                        </p>

                                        <table>
                                            <thead>
                                                <tr>
                                                    <td>AREA</td>
                                                    <td>OPERATORS</td>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Creation</td>
                                                    <td>from, fromEvent, of</td>
                                                </tr>
                                                <tr>
                                                    <td>Combination	</td>
                                                    <td>combineLatest, concat, merge, startWith , withLatestFrom, zip</td>
                                                </tr>
                                                <tr>
                                                    <td>Filtering</td>
                                                    <td>debounceTime, distinctUntilChanged, filter, take, takeUntil</td>
                                                </tr>
                                                <tr>
                                                    <td>Transformation</td>
                                                    <td>bufferTime, concatMap, map, mergeMap, scan, switchMap</td>
                                                </tr>
                                                <tr>
                                                    <td>Utility</td>
                                                    <td>tap</td>
                                                </tr>
                                                <tr>
                                                    <td>Multicasting</td>
                                                    <td>share</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_4>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Error handling
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_4>
                                    <ng-container #description_2_4>
                                        <p>In addition to the error() handler that you provide on subscription, RxJS provides the catchError operator that lets you handle known errors in the observable recipe.</p>
                                        <p>For instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn’t exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.</p>
                                        <p>Here's an example of using the catchError operator to do this:</p>
                                        <code-example code="
                                        import { Observable, of } from 'rxjs';
                                        import { ajax } from 'rxjs/ajax';
                                        import { map, catchError } from 'rxjs/operators';
                                        
                                        // Return 'response' from the API. If an error happens,
                                        // return an empty array.
                                        const apiData = ajax('/api/data').pipe(
                                          map((res: any) => {
                                            if (!res.response) {
                                              throw new Error('Value expected!');
                                            }
                                            return res.response;
                                          }),
                                          catchError(() => of([]))
                                        );
                                        
                                        apiData.subscribe({
                                          next(x: T) { console.log('data: ', x); },
                                          error() { console.log('errors already caught... will not run'); }
                                        });
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_5>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Retry failed observable
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_5>
                                    <ng-container #description_2_5>
                                        <p>Where the catchError operator provides a simple path of recovery, the retry operator lets you retry a failed request.</p>
                                        <p>Use the retry operator before the catchError operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.</p>
                                        <p>The following converts the previous example to retry the request before catching the error:</p>
                                        <code-example code="
                                        import { Observable, of } from 'rxjs';
                                        import { ajax } from 'rxjs/ajax';
                                        import { map, retry, catchError } from 'rxjs/operators';
                                        
                                        const apiData = ajax('/api/data').pipe(
                                          map((res: any) => {
                                            if (!res.response) {
                                              console.log('Error occurred.');
                                              throw new Error('Value expected!');
                                            }
                                            return res.response;
                                          }),
                                          retry(3), // Retry up to 3 times before failing
                                          catchError(() => of([]))
                                        );
                                        
                                        apiData.subscribe({
                                          next(x: T) { console.log('data: ', x); },
                                          error() { console.log('errors already caught... will not run'); }
                                        });
                                        "></code-example>
                                        <p class="note">
                                            Do not retry authentication requests, since these should only be initiated by user action. We don't want to lock out user accounts with repeated login requests that the user has not initiated.
                                        </p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_6>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Naming conventions for observables
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_6>
                                    <ng-container #description_2_6>
                                        <p>Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing “$” sign.</p>
                                        <p>This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to use the same name with or without the “$”.</p>
                                        <p>For example:</p>
                                        <code-example code="
                                        import { Component } from '@angular/core';
                                        import { Observable } from 'rxjs';
                                        
                                        @Component({
                                          selector: 'app-stopwatch',
                                          templateUrl: './stopwatch.component.html'
                                        })
                                        export class StopwatchComponent {
                                        
                                          stopwatchValue = 0;
                                          stopwatchValue$!: Observable<number>;
                                        
                                          start() {
                                            this.stopwatchValue$.subscribe(num =>
                                              this.stopwatchValue = num
                                            );
                                          }
                                        }
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content3>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Observables in Angular
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content3Content>
                        <ng-container #description_3>
                            <p>Angular makes use of observables as an interface to handle a variety of common asynchronous operations. For example:</p>
                            <ul>
                                <li>You can define custom events that send observable output data from a child to a parent component.</li>
                                <li>The HTTP module uses observables to handle AJAX requests and responses.</li>
                                <li>The Router and Forms modules use observables to listen for and respond to user-input events.</li>
                            </ul>
                        </ng-container>

                        <ng-container #content2_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Transmitting data between components
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_1>
                                    <ng-container #description_2_1>
                                        <p>Angular provides an EventEmitter class that is used when publishing values from a component through the @Output() decorator. EventEmitter extends RxJS Subject, adding an emit() method so it can send arbitrary values. When you call emit(), it passes the emitted value to the next() method of any subscribed observer.</p>
                                        <p>A good example of usage can be found in the EventEmitter documentation. Here is the example component that listens for open and close events:</p>
                                        <code-example code="
                                        <app-zippy (open)='onOpen($event)' (close)='onClose($event)'></app-zippy>
                                        "></code-example>
                                        <p>Here is the component definition:</p>
                                        <code-example code="
                                        @Component({
                                            selector: 'app-zippy',
                                            template: `
                                              <div class='zippy'>
                                                <div (click)='toggle()'>Toggle</div>
                                                <div [hidden]='!visible'>
                                                  <ng-content></ng-content>
                                                </div>
                                              </div>
                                            `,
                                          })
                                          export class ZippyComponent {
                                            visible = true;
                                            @Output() open = new EventEmitter<any>();
                                            @Output() close = new EventEmitter<any>();
                                          
                                            toggle() {
                                              this.visible = !this.visible;
                                              if (this.visible) {
                                                this.open.emit(null);
                                              } else {
                                                this.close.emit(null);
                                              }
                                            }
                                          }
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_2>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        HTTP
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_2>
                                    <ng-container #description_2_2>
                                        <p>Angular’s HttpClient returns observables from HTTP method calls. For instance, http.get(‘/api’) returns an observable. This provides several advantages over promise-based HTTP APIs:</p>
                                        <ul>
                                            <li>Observables do not mutate the server response (as can occur through chained .then() calls on promises). Instead, you can use a series of operators to transform values as needed.</li>
                                            <li>HTTP requests are cancellable through the unsubscribe() method.</li>
                                            <li>Requests can be configured to get progress event updates.</li>
                                            <li>Failed requests can be retried easily.</li>
                                        </ul>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_3>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Async pipe
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_3>
                                    <ng-container #description_2_3>
                                        <p>The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted. When a new value is emitted, the pipe marks the component to be checked for changes.</p>
                                        <p>The following example binds the time observable to the component's view. The observable continuously updates the view with the current time. </p>
                                        <code-example code="
                                        @Component({
                                            selector: 'async-observable-pipe',
                                            template: `<div><code>observable|async</code>:
                                                 Time: [[ time | async ]]</div>`
                                          })
                                          export class AsyncObservablePipeComponent {
                                            time = new Observable<string>(observer => {
                                              setInterval(() => observer.next(new Date().toString()), 1000);
                                            });
                                          }
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_4>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Router
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_4>
                                    <ng-container #description_2_4>
                                        <p>Router.events provides events as observables. You can use the filter() operator from RxJS to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process. Here's an example:</p>
                                        <code-example code="
                                        import { Router, NavigationStart } from '@angular/router';
                                        import { filter } from 'rxjs/operators';
                                        
                                        @Component({
                                          selector: 'app-routable',
                                          template: 'Routable1Component template'
                                        })
                                        export class Routable1Component implements OnInit {
                                        
                                          navStart: Observable<NavigationStart>;
                                        
                                          constructor(router: Router) {
                                            // Create a new Observable that publishes only the NavigationStart event
                                            this.navStart = router.events.pipe(
                                              filter(evt => evt instanceof NavigationStart)
                                            ) as Observable<NavigationStart>;
                                          }
                                        
                                          ngOnInit() {
                                            this.navStart.subscribe(() => console.log('Navigation Started!'));
                                          }
                                        }
                                        "></code-example>

                                        <p>The ActivatedRoute is an injected router service that makes use of observables to get information about a route path and parameters. For example, ActivatedRoute.url contains an observable that reports the route path or paths. Here's an example:</p>
                                        <code-example code="
                                        import { ActivatedRoute } from '@angular/router';

                                        @Component({
                                          selector: 'app-routable',
                                          template: 'Routable2Component template'
                                        })
                                        export class Routable2Component implements OnInit {
                                          constructor(private activatedRoute: ActivatedRoute) {}
                                        
                                          ngOnInit() {
                                            this.activatedRoute.url
                                              .subscribe(url => console.log('The URL changed to: ' + url));
                                          }
                                        }
                                        "></code-example>
                                        
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content2_5>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Reactive forms
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content2Content_5>
                                    <ng-container #description_2_5>
                                        <p>Reactive forms have properties that use observables to monitor form control values. The FormControl properties valueChanges and statusChanges contain observables that raise change events. Subscribing to an observable form-control property is a way of triggering application logic within the component class. For example:</p>
                                        <code-example code="
                                        import { FormGroup } from '@angular/forms';

                                        @Component({
                                          selector: 'my-component',
                                          template: 'MyComponent Template'
                                        })
                                        export class MyComponent implements OnInit {
                                          nameChangeLog: string[] = [];
                                          heroForm!: FormGroup;
                                        
                                          ngOnInit() {
                                            this.logNameChange();
                                          }
                                          logNameChange() {
                                            const nameControl = this.heroForm.get('name');
                                            nameControl?.valueChanges.forEach(
                                              (value: string) => this.nameChangeLog.push(value)
                                            );
                                          }
                                        }
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content4>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Practical observable usage
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content4Content>
                        <ng-container #description_4>
                            <p>Here are some examples of domains in which observables are particularly useful.</p>
                        </ng-container>

                        <ng-container #content4_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Type-ahead suggestions
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content4Content_1>
                                    <ng-container #description_4_1>
                                        <p>Observables can simplify the implementation of type-ahead suggestions. Typically, a type-ahead has to do a series of separate tasks:</p>
                                        <ul>
                                            <li>Listen for data from an input.</li>
                                            <li>Trim the value (remove whitespace) and make sure it’s a minimum length.</li>
                                            <li>Debounce (so as not to send off API requests for every keystroke, but instead wait for a break in keystrokes).</li>
                                            <li>Don’t send a request if the value stays the same (rapidly hit a character, then backspace, for instance).</li>
                                            <li>Cancel ongoing AJAX requests if their results will be invalidated by the updated results.</li>
                                        </ul>
                                        <p>Writing this in full JavaScript can be quite involved. With observables, you can use a simple series of RxJS operators:</p>
                                        <code-example code="
                                        import { fromEvent, Observable } from 'rxjs';
                                        import { debounceTime, distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';
                                        
                                        const searchBox = document.getElementById('search-box') as HTMLInputElement;
                                        
                                        const typeahead = fromEvent(searchBox, 'input').pipe(
                                          map(e => (e.target as HTMLInputElement).value),
                                          filter(text => text.length > 2),
                                          debounceTime(10),
                                          distinctUntilChanged(),
                                          switchMap(searchTerm => ajax(`/api/endpoint?search=${searchTerm}`))
                                        );
                                        
                                        typeahead.subscribe(data => {
                                          // Handle the data from the API
                                        });
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content4_2>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Exponential backoff
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content4Content_2>
                                    <ng-container #description_4_2>
                                        <p>Exponential backoff is a technique in which you retry an API after failure, making the time in between retries longer after each consecutive failure, with a maximum number of retries after which the request is considered to have failed. This can be quite complex to implement with promises and other methods of tracking AJAX calls. With observables, it is very easy:</p>
                                        <code-example code="
                                        import { of, pipe, range, throwError, timer, zip } from 'rxjs';
                                        import { ajax } from 'rxjs/ajax';
                                        import { map, mergeMap, retryWhen } from 'rxjs/operators';
                                        
                                        export function backoff(maxTries: number, delay: number) {
                                          return pipe(
                                            retryWhen(attempts =>
                                              zip(range(1, maxTries + 1), attempts).pipe(
                                                mergeMap(([i, err]) => (i > maxTries) ? throwError(err) : of(i)),
                                                map(i => i * i),
                                                mergeMap(v => timer(v * delay)),
                                              ),
                                            ),
                                          );
                                        }
                                        
                                        ajax('/api/endpoint')
                                          .pipe(backoff(3, 250))
                                          .subscribe(function handleData(data) { /* ... */ });
                                        "></code-example>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content5>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Observables compared to other techniques
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content5Content>
                        <ng-container #description_5>
                            <p>You can often use observables instead of promises to deliver values asynchronously. Similarly, observables can take the place of event handlers. Finally, because observables deliver multiple values, you can use them where you might otherwise build and operate on arrays.</p>
                            <p>Observables behave somewhat differently from the alternative techniques in each of these situations, but offer some significant advantages. Here are detailed comparisons of the differences.</p>
                        </ng-container>

                        <ng-container #content5_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Observables compared to promises
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content5Content_1>
                                    <ng-container #description_5_1>
                                        <p>Observables are often compared to promises. Here are some key differences:</p>
                                        <ul>
                                            <li>Observables are declarative; computation does not start until subscription. Promises execute immediately on creation. This makes observables useful for defining recipes that can be run whenever you need the result.</li>
                                            <li>Observables provide many values. Promises provide one. This makes observables useful for getting multiple values over time.</li>
                                            <li>Observables differentiate between chaining and subscription. Promises only have .then() clauses. This makes observables useful for creating complex transformation recipes to be used by other part of the system, without causing the work to be executed.</li>
                                            <li>Observables subscribe() is responsible for handling errors. Promises push errors to the child promises. This makes observables useful for centralized and predictable error handling.</li>
                                        </ul>
                                    </ng-container>

                                    <ng-container #content5_1_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Creation and subscription
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content5Content_1_1>
                                                <ng-container #description_5_1_1>
                                                    <ul>
                                                        <li>
                                                            <p>Observables are not executed until a consumer subscribes. The subscribe() executes the defined behavior once, and it can be called again. Each subscription has its own computation. Resubscription causes recomputation of values.</p>
                                                            <code-example code="
                                                            // declare a publishing operation
                                                            const observable = new Observable<number>(observer => {
                                                              // Subscriber fn...
                                                            });
                                                            
                                                            // initiate execution
                                                            observable.subscribe(value => {
                                                              // observer handles notifications
                                                            });
                                                            "></code-example>
                                                        </li>
                                                        <li>
                                                            <p>Promises execute immediately, and just once. The computation of the result is initiated when the promise is created. There is no way to restart work. All then clauses (subscriptions) share the same computation.</p>
                                                            <code-example code="
                                                            // initiate execution
                                                            let promise = new Promise<number>(resolve => {
                                                            // Executer fn...
                                                            });
                                                            promise.then(value => {
                                                            // handle result here
                                                            });
                                                            "></code-example>
                                                        </li>
                                                    </ul>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content5_1_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Chaining
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content5Content_1_2>
                                                <ng-container #description_5_1_2>
                                                    <ul>
                                                        <li>
                                                            <p>Observables differentiate between transformation function such as a map and subscription. Only subscription activates the subscriber function to start computing the values.</p>
                                                            <code-example code="
                                                            observable.pipe(map(v => 2 * v));
                                                            "></code-example>
                                                        </li>
                                                        <li>
                                                            <p>Promises do not differentiate between the last .then clauses (equivalent to subscription) and intermediate .then clauses (equivalent to map).</p>
                                                            <code-example code="
                                                            promise.then(v => 2 * v);
                                                            "></code-example>
                                                        </li>
                                                    </ul>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content5_1_3>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Cancellation
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content5Content_1_3>
                                                <ng-container #description_5_1_3>
                                                    <ul>
                                                        <li>
                                                            <p>Observable subscriptions are cancellable. Unsubscribing removes the listener from receiving further values, and notifies the subscriber function to cancel work.</p>
                                                            <code-example code="
                                                            const subscription = observable.subscribe(() => {
                                                                // observer handles notifications
                                                              });
                                                              
                                                              subscription.unsubscribe();
                                                            "></code-example>
                                                        </li>
                                                        <li>Promises are not cancellable.</li>
                                                    </ul>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content5_1_4>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Error handling
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content5Content_1_4>
                                                <ng-container #description_5_1_4>
                                                    <ul>
                                                        <li>
                                                            <p>Observable execution errors are delivered to the subscriber's error handler, and the subscriber automatically unsubscribes from the observable.</p>
                                                            <code-example code="
                                                            observable.subscribe(() => {
                                                                throw new Error('my error');
                                                              });
                                                            "></code-example>
                                                        </li>
                                                        <li>
                                                            <p>Promises push errors to the child promises.</p>
                                                            <code-example code="
                                                            promise.then(() => {
                                                                throw new Error('my error');
                                                              });
                                                            "></code-example>
                                                        </li>
                                                    </ul>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content5_1_5>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Cheat sheet
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content5Content_1_5>
                                                <ng-container #description_5_1_5>
                                                    <p>The following code snippets illustrate how the same kind of operation is defined using observables and promises.</p>
                                                    <table>
                                                        <thead>
                                                            <tr>
                                                                <td>OPERATION</td>
                                                                <td>OBSERVABLE</td>
                                                                <td>PROMISE</td>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>Creation</td>
                                                                <td>
                                                                    {{'
                                                                        new Observable((observer) => {
                                                                        observer.next(123);
                                                                      });
                                                                    '}}
                                                                </td>
                                                                <td>
                                                                    {{'
                                                                        new Promise((resolve, reject) => {
                                                                        resolve(123);
                                                                      });
                                                                    '}}
                                                                </td>
                                                            </tr>
                                                            <tr>
                                                                <td>Transform</td>
                                                                <td>obs.pipe(map((value) => value * 2));</td>
                                                                <td>promise.then((value) => value * 2);</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Subscribe</td>
                                                                <td>{{'
                                                                    sub = obs.subscribe((value) => {
                                                                        console.log(value)
                                                                      });
                                                                      '}}
                                                                </td>
                                                                <td>{{'
                                                                    promise.then((value) => {
                                                                        console.log(value);
                                                                      });
                                                                      '}}
                                                                </td>
                                                            </tr>
                                                            <tr>
                                                                <td>Unsubscribe</td>
                                                                <td>sub.unsubscribe();</td>
                                                                <td>Implied by promise resolution.</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_2>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Observables compared to events API
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content5Content_2>
                                    <ng-container #description_5_2>
                                        <p>Observables are very similar to event handlers that use the events API. Both techniques define notification handlers, and use them to process multiple values delivered over time. Subscribing to an observable is equivalent to adding an event listener. One significant difference is that you can configure an observable to transform an event before passing the event to the handler.</p>
                                        <p>Using observables to handle events and asynchronous operations can have the advantage of greater consistency in contexts such as HTTP requests.</p>
                                        <p>Here are some code samples that illustrate how the same kind of operation is defined using observables and the events API.</p>
                                        <table>
                                            <thead>
                                                <tr>
                                                    <td></td>
                                                    <td>Observable</td>
                                                    <td>Events API</td>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Creation & cancellation</td>
                                                    <td>
                                                        // Setup
                                                        const clicks$ = fromEvent(buttonEl, ‘click’);
                                                        // Begin listening
                                                        const subscription = clicks$
                                                        .subscribe(e => console.log(‘Clicked’, e))
                                                        // Stop listening
                                                        subscription.unsubscribe();
                                                    </td>
                                                    <td>{{'
                                                        function handler(e) {
                                                            console.log(‘Clicked’, e);
                                                          }
                                                          // Setup & begin listening
                                                          button.addEventListener(‘click’, handler);
                                                          // Stop listening
                                                          button.removeEventListener(‘click’, handler);
                                                          '}}
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>Subscription</td>
                                                    <td>{{'
                                                        observable.subscribe(() => {
                                                            // notification handlers here
                                                          });
                                                          '}}
                                                    </td>
                                                    <td>
                                                        {{'
                                                        element.addEventListener(eventName, (event) => {
                                                            // notification handler here
                                                          });
                                                          '}}
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>Configuration</td>
                                                    <td>
                                                        Listen for keystrokes, but provide a stream representing the value in the input.
                                                        fromEvent(inputEl, 'keydown').pipe(
                                                        map(e => e.target.value)
                                                        );
                                                    </td>
                                                    <td>
                                                        {{'
                                                        Does not support configuration.
                                                        element.addEventListener(eventName, (event) => {
                                                        // Cannot change the passed Event into another
                                                        // value before it gets to the handler
                                                        });
                                                        '}}
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content5_3>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Observables compared to arrays
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content5Content_3>
                                    <ng-container #description_5_3>
                                        <p>An observable produces values over time. An array is created as a static set of values. In a sense, observables are asynchronous where arrays are synchronous. In the following examples, ➞ implies asynchronous value delivery.</p>
                                        <table>
                                            <thead>
                                                <tr>
                                                    <td></td>
                                                    <td>Observable</td>
                                                    <td>Array</td>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Given</td>
                                                    <td>
                                                        obs: ➞1➞2➞3➞5➞7
                                                        obsB: ➞'a'➞'b'➞'c'
                                                    </td>
                                                    <td>
                                                        arr: [1, 2, 3, 5, 7]
                                                        arrB: ['a', 'b', 'c']
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>concat()</td>
                                                    <td>
                                                        concat(obs, obsB)
                                                        ➞1➞2➞3➞5➞7➞'a'➞'b'➞'c'
                                                    </td>
                                                    <td>
                                                        arr.concat(arrB)
                                                        [1,2,3,5,7,'a','b','c']
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>filter()</td>
                                                    <td>
                                                        obs.pipe(filter((v) => v>3))
                                                        ➞5➞7
                                                    </td>
                                                    <td>
                                                        arr.filter((v) => v>3)
                                                        [5, 7]
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>find()</td>
                                                    <td>
                                                        obs.pipe(find((v) => v>3))
                                                        ➞5
                                                    </td>
                                                    <td>
                                                        arr.find((v) => v>3)
                                                        5
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>findIndex()</td>
                                                    <td>
                                                        obs.pipe(findIndex((v) => v>3))
                                                        ➞3
                                                    </td>
                                                    <td>
                                                        arr.findIndex((v) => v>3)
                                                        3
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>forEach()</td>
                                                    <td>{{'
                                                        obs.pipe(tap((v) => {
                                                            console.log(v);
                                                          }))
                                                          1
                                                          2
                                                          3
                                                          5
                                                          7
                                                          '}}
                                                    </td>
                                                    <td>{{'
                                                        arr.forEach((v) => {
                                                            console.log(v);
                                                          })
                                                          1
                                                          2
                                                          3
                                                          5
                                                          7
                                                          '}}
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>map()</td>
                                                    <td>
                                                        obs.pipe(map((v) => -v))
                                                        ➞-1➞-2➞-3➞-5➞-7
                                                    </td>
                                                    <td>
                                                        arr.map((v) => -v)
                                                        [-1, -2, -3, -5, -7]
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>reduce()</td>
                                                    <td>
                                                        obs.pipe(reduce((s,v)=> s+v, 0))
                                                        ➞18
                                                    </td>
                                                    <td>
                                                        arr.reduce((s,v) => s+v, 0)
                                                        18
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>


        </ng-container>
    </mat-expansion-panel>
</ng-template>

<ng-template #dependencyInjectionTemplate>
    <mat-expansion-panel>
        <mat-expansion-panel-header>
          <mat-panel-title>
            Dependency Injection
          </mat-panel-title>
        </mat-expansion-panel-header>

        <ng-container #dependencyInjectionContent>
            <ng-container #description></ng-container>

            <ng-container #content1>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Hierarchical injectors
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content1Content>
                        <ng-container #description_1>
                            <p>Injectors in Angular have rules that you can leverage to achieve the desired visibility of injectables in your applications. By understanding these rules, you can determine in which NgModule, Component or Directive you should declare a provider.</p>
                        </ng-container>

                        <ng-container #content1_1>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Two injector hierarchies
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_1>
                                    <ng-container #description_1_1>
                                        <p>There are two injector hierarchies in Angular:</p>
                                        <ol>
                                            <li>ModuleInjector hierarchy—configure a ModuleInjector in this hierarchy using an @NgModule() or @Injectable() annotation.</li>
                                            <li>ElementInjector hierarchy—created implicitly at each DOM element. An ElementInjector is empty by default unless you configure it in the providers property on @Directive() or @Component().</li>
                                        </ol>
                                    </ng-container>

                                    <ng-container #content1_1_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    ModuleInjector
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_1>
                                                <ng-container #description_1_1_1>
                                                    <p>The ModuleInjector can be configured in one of two ways:</p>
                                                    <ul>
                                                        <li>Using the @Injectable() providedIn property to refer to @NgModule(), or root.</li>
                                                        <li>Using the @NgModule() providers array.</li>
                                                    </ul>
                                                    <span class="note">
                                                        <p class="header">Tree-shaking and @Injectable()</p>
                                                        <p>Using the @Injectable() providedIn property is preferable to the @NgModule() providers array because with @Injectable() providedIn, optimization tools can perform tree-shaking, which removes services that your application isn't using and results in smaller bundle sizes.</p>
                                                        <p>Tree-shaking is especially useful for a library because the application which uses the library may not have a need to inject it. Read more about tree-shakable providers in Introduction to services and dependency injection.</p>
                                                    </span>
                                                    <p>ModuleInjector is configured by the @NgModule.providers and NgModule.imports property. ModuleInjector is a flattening of all of the providers arrays which can be reached by following the NgModule.imports recursively.</p>
                                                    <p>Child ModuleInjectors are created when lazy loading other @NgModules.</p>
                                                    <p>Provide services with the providedIn property of @Injectable() as follows:</p>
                                                    <code-example code="
                                                    import { Injectable } from '@angular/core';

                                                    @Injectable({
                                                      providedIn: 'root'  // <--provides this service in the root ModuleInjector
                                                    })
                                                    export class ItemService {
                                                      name = 'telephone';
                                                    }
                                                    "></code-example>
                                                    <p>The @Injectable() decorator identifies a service class. The providedIn property configures a specific ModuleInjector, here root, which makes the service available in the root ModuleInjector.</p>
                                                
                                                    <br>
                                                    <h3>Platform injector</h3>
                                                    <p>There are two more injectors above root, an additional ModuleInjector and NullInjector().</p>
                                                    <p>Consider how Angular bootstraps the application with the following in main.ts:</p>
                                                    <code-example code="
                                                    platformBrowserDynamic().bootstrapModule(AppModule).then(ref => {...})
                                                    "></code-example>
                                                    <p>The bootstrapModule() method creates a child injector of the platform injector which is configured by the AppModule. This is the root ModuleInjector.</p>
                                                    <p>The platformBrowserDynamic() method creates an injector configured by a PlatformModule, which contains platform-specific dependencies. This allows multiple applications to share a platform configuration. For example, a browser has only one URL bar, no matter how many applications you have running. You can configure additional platform-specific providers at the platform level by supplying extraProviders using the platformBrowser() function.</p>
                                                    <p>The next parent injector in the hierarchy is the NullInjector(), which is the top of the tree. If you've gone so far up the tree that you are looking for a service in the NullInjector(), you'll get an error unless you've used @Optional() because ultimately, everything ends at the NullInjector() and it returns an error or, in the case of @Optional(), null. For more information on @Optional(), see the @Optional() section of this guide.</p>
                                                    <p>The following diagram represents the relationship between the root ModuleInjector and its parent injectors as the previous paragraphs describe.</p>
                                                    <br>
                                                    <p>While the name root is a special alias, other ModuleInjectors don't have aliases. You have the option to create ModuleInjectors whenever a dynamically loaded component is created, such as with the Router, which will create child ModuleInjectors.</p>
                                                    <p>All requests forward up to the root injector, whether you configured it with the bootstrapModule() method, or registered all providers with root in their own services.</p>

                                                    <span class="note">
                                                        <p class="header">@Injectable() vs. @NgModule()</p>
                                                        <p>If you configure an app-wide provider in the @NgModule() of AppModule, it overrides one configured for root in the @Injectable() metadata. You can do this to configure a non-default provider of a service that is shared with multiple applications.</p>
                                                        <p>Here is an example of the case where the component router configuration includes a non-default location strategy by listing its provider in the providers list of the AppModule.</p>
                                                        <code-example code="
                                                        providers: [
                                                        { provide: LocationStrategy, useClass: HashLocationStrategy }
                                                      ]
                                                        "></code-example>
                                                    </span>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_1_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    ElementInjector
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_2>
                                                <ng-container #description_1_1_2>
                                                    <p>Angular creates ElementInjectors implicitly for each DOM element.</p>
                                                    <p>Providing a service in the @Component() decorator using its providers or viewProviders property configures an ElementInjector. For example, the following TestComponent configures the ElementInjector by providing the service as follows:</p>
                                                    <code-example code="
                                                    @Component({
                                                        ...
                                                        providers: [{ provide: ItemService, useValue: { name: 'lamp' } }]
                                                      })
                                                      export class TestComponent
                                                    "></code-example>
                                                    <p class="note">Note: See the resolution rules section to understand the relationship between the ModuleInjector tree and the ElementInjector tree.</p>
                                                    <p>When you provide services in a component, that service is available by way of the ElementInjector at that component instance. It may also be visible at child component/directives based on visibility rules described in the resolution rules section.</p>
                                                    <p>When the component instance is destroyed, so is that service instance.</p>

                                                    <br>
                                                    <h3>@Directive() and @Component()</h3>
                                                    <p>A component is a special type of directive, which means that just as @Directive() has a providers property, @Component() does too. This means that directives as well as components can configure providers, using the providers property. When you configure a provider for a component or directive using the providers property, that provider belongs to the ElementInjector of that component or directive. Components and directives on the same element share an injector.</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_2>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Resolution rules
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_2>
                                    <ng-container #description_1_2>
                                        <p>When resolving a token for a component/directive, Angular resolves it in two phases:</p>
                                        <ol>
                                            <li>Against the ElementInjector hierarchy (its parents)</li>
                                            <li>Against the ModuleInjector hierarchy (its parents)</li>
                                        </ol>
                                        <p>When a component declares a dependency, Angular tries to satisfy that dependency with its own ElementInjector. If the component's injector lacks the provider, it passes the request up to its parent component's ElementInjector.</p>
                                        <p>The requests keep forwarding up until Angular finds an injector that can handle the request or runs out of ancestor ElementInjectors.</p>
                                        <p>If Angular doesn't find the provider in any ElementInjectors, it goes back to the element where the request originated and looks in the ModuleInjector hierarchy. If Angular still doesn't find the provider, it throws an error.</p>
                                        <p>If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to resolve the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_3>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Resolution modifiers
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_3>
                                    <ng-container #description_1_3>
                                        <p>Angular's resolution behavior can be modified with @Optional(), @Self(), @SkipSelf() and @Host(). Import each of them from @angular/core and use each in the component class constructor when you inject your service.</p>
                                    </ng-container>

                                    <ng-container #content1_3_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Types of modifiers
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_3_1>
                                                <ng-container #description_1_3_1>
                                                    <p>Resolution modifiers fall into three categories:</p>
                                                    <ol>
                                                        <li>What to do if Angular doesn't find what you're looking for, that is @Optional()</li>
                                                        <li>Where to start looking, that is @SkipSelf()</li>
                                                        <li>Where to stop looking, @Host() and @Self()</li>
                                                    </ol>
                                                    <p>By default, Angular always starts at the current Injector and keeps searching all the way up. Modifiers allow you to change the starting (self) or ending location.</p>
                                                    <p>Additionally, you can combine all of the modifiers except @Host() and @Self() and of course @SkipSelf() and @Self().</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_3_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @Optional()
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_3_2>
                                                <ng-container #description_1_3_2>
                                                    <p>@Optional() allows Angular to consider a service you inject to be optional. This way, if it can't be resolved at runtime, Angular resolves the service as null, rather than throwing an error. In the following example, the service, OptionalService, isn't provided in the service, @NgModule(), or component class, so it isn't available anywhere in the app.</p>
                                                    <code-example code="
                                                    export class OptionalComponent {
                                                        constructor(@Optional() public optional?: OptionalService) {}
                                                      }
                                                    "></code-example>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_3_3>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @Self()
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_3_3>
                                                <ng-container #description_1_3_3>
                                                    <p>Use @Self() so that Angular will only look at the ElementInjector for the current component or directive.</p>
                                                    <p>A good use case for @Self() is to inject a service but only if it is available on the current host element. To avoid errors in this situation, combine @Self() with @Optional().</p>
                                                    <p>For example, in the following SelfComponent, notice the injected LeafService in the constructor.</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-self-no-data',
                                                        templateUrl: './self-no-data.component.html',
                                                        styleUrls: ['./self-no-data.component.css']
                                                      })
                                                      export class SelfNoDataComponent {
                                                        constructor(@Self() @Optional() public leaf?: LeafService) { }
                                                      }
                                                    "></code-example>
                                                    <p>In this example, there is a parent provider and injecting the service will return the value, however, injecting the service with @Self() and @Optional() will return null because @Self() tells the injector to stop searching in the current host element.</p>
                                                    <p>Another example shows the component class with a provider for FlowerService. In this case, the injector looks no further than the current ElementInjector because it finds the FlowerService and returns the yellow flower 🌼.</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-self',
                                                        templateUrl: './self.component.html',
                                                        styleUrls: ['./self.component.css'],
                                                        providers: [{ provide: FlowerService, useValue: { emoji: '🌼' } }]
                                                      
                                                      })
                                                      export class SelfComponent {
                                                        constructor(@Self() public flower: FlowerService) {}
                                                      }
                                                    "></code-example>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_3_4>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @SkipSelf()
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_3_4>
                                                <ng-container #description_1_3_4>
                                                    <p>@SkipSelf() is the opposite of @Self(). With @SkipSelf(), Angular starts its search for a service in the parent ElementInjector, rather than in the current one. So if the parent ElementInjector were using the value 🌿 (fern) for emoji , but you had 🍁 (maple leaf) in the component's providers array, Angular would ignore 🍁 (maple leaf) and use 🌿 (fern).</p>
                                                    <p>To see this in code, assume that the following value for emoji is what the parent component were using, as in this service:</p>
                                                    <code-example code="
                                                    export class LeafService {
                                                        emoji = '🌿';
                                                      }
                                                    "></code-example>
                                                    <p>Imagine that in the child component, you had a different value, 🍁 (maple leaf) but you wanted to use the parent's value instead. This is when you'd use @SkipSelf():</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-skipself',
                                                        templateUrl: './skipself.component.html',
                                                        styleUrls: ['./skipself.component.css'],
                                                        // Angular would ignore this LeafService instance
                                                        providers: [{ provide: LeafService, useValue: { emoji: '🍁' } }]
                                                      })
                                                      export class SkipselfComponent {
                                                        // Use @SkipSelf() in the constructor
                                                        constructor(@SkipSelf() public leaf: LeafService) { }
                                                      }
                                                    "></code-example>
                                                    <p>In this case, the value you'd get for emoji would be 🌿 (fern), not 🍁 (maple leaf).</p>

                                                    <br>
                                                    <h3>@SkipSelf() with @Optional()</h3>
                                                    <p>Use @SkipSelf() with @Optional() to prevent an error if the value is null. In the following example, the Person service is injected in the constructor. @SkipSelf() tells Angular to skip the current injector and @Optional() will prevent an error should the Person service be null.</p>
                                                    <code-example code="
                                                    class Person {
                                                        constructor(@Optional() @SkipSelf() parent?: Person) {}
                                                      }
                                                    "></code-example>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_3_5>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @Host()
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_3_5>
                                                <ng-container #description_1_3_5>
                                                    <p>@Host() lets you designate a component as the last stop in the injector tree when searching for providers. Even if there is a service instance further up the tree, Angular won't continue looking. Use @Host() as follows:</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-host',
                                                        templateUrl: './host.component.html',
                                                        styleUrls: ['./host.component.css'],
                                                        //  provide the service
                                                        providers: [{ provide: FlowerService, useValue: { emoji: '🌼' } }]
                                                      })
                                                      export class HostComponent {
                                                        // use @Host() in the constructor when injecting the service
                                                        constructor(@Host() @Optional() public flower?: FlowerService) { }
                                                      
                                                      }
                                                    "></code-example>
                                                    <p>Since HostComponent has @Host() in its constructor, no matter what the parent of HostComponent might have as a flower.emoji value, the HostComponent will use 🌼 (yellow flower).</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_4>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Logical structure of the template
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_4>
                                    <ng-container #description_1_4>
                                        <p>When you provide services in the component class, services are visible within the ElementInjector tree relative to where and how you provide those services.</p>
                                        <p>Understanding the underlying logical structure of the Angular template will give you a foundation for configuring services and in turn control their visibility.</p>
                                        <p>Components are used in your templates, as in the following example:</p>
                                        <code-example code="
                                        <app-root>
                                            <app-child></app-child>
                                        </app-root>
                                        "></code-example>

                                        <p class="note">
                                            Note: Usually, you declare the components and their templates in separate files. For the purposes of understanding how the injection system works, it is useful to look at them from the point of view of a combined logical tree. The term logical distinguishes it from the render tree (your application DOM tree). To mark the locations of where the component templates are located, this guide uses the < #VIEW> pseudo element, which doesn't actually exist in the render tree and is present for mental model purposes only.
                                        </p>
                                        <p>The following is an example of how the < app-root> and < app-child> view trees are combined into a single logical tree:</p>
                                        <code-example code="
                                        <app-root>
                                            <#VIEW>
                                              <app-child>
                                               <#VIEW>
                                                 ...content goes here...
                                               </#VIEW>
                                              </app-child>
                                            </#VIEW>
                                          </app-root>
                                        "></code-example>
                                        <p>Understanding the idea of the <#VIEW> demarcation is especially significant when you configure services in the component class.</p>
                                    </ng-container>
                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_5>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Providing services in @Component()
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_5>
                                    <ng-container #description_1_5>
                                        <p>How you provide services using a @Component() (or @Directive()) decorator determines their visibility. The following sections demonstrate providers and viewProviders along with ways to modify service visibility with @SkipSelf() and @Host().</p>
                                        <p>A component class can provide services in two ways:</p>
                                        <ol>
                                            <li>
                                                <p>with a providers array</p>
                                                <code-example code="
                                                @Component({
                                                    ...
                                                    providers: [
                                                      {provide: FlowerService, useValue: {emoji: '🌺'}}
                                                    ]
                                                  })
                                                "></code-example>
                                            </li>
                                            <li>
                                                <p>with a viewProviders array</p>
                                                <code-example code="
                                                @Component({
                                                    ...
                                                    viewProviders: [
                                                      {provide: AnimalService, useValue: {emoji: '🐶'}}
                                                    ]
                                                  })
                                                "></code-example>
                                            </li>
                                        </ol>

                                        <p>To understand how the providers and viewProviders influence service visibility differently, the following sections build a live example / download example step-by-step and compare the use of providers and viewProviders in code and a logical tree.</p>
                                        <span class="note">
                                            <p>NOTE: In the logical tree, you'll see @Provide, @Inject, and @NgModule, which are not real HTML attributes but are here to demonstrate what is going on under the hood.</p>
                                            <ul>
                                                <li>@Inject(Token)=>Value demonstrates that if Token is injected at this location in the logical tree its value would be Value.</li>
                                                <li>@Provide(Token=Value) demonstrates that there is a declaration of Token provider with value Value at this location in the logical tree.</li>
                                                <li>@NgModule(Token) demonstrates that a fallback NgModule injector should be used at this location.</li>
                                            </ul>
                                        </span>
                                    </ng-container>

                                    <ng-container #content1_5_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Example app structure
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_5_1>
                                                <ng-container #description_1_5_1>
                                                    <p>The example application has a FlowerService provided in root with an emoji value of 🌺 (red hibiscus).</p>
                                                    <code-example code="
                                                    @Injectable({
                                                        providedIn: 'root'
                                                      })
                                                      export class FlowerService {
                                                        emoji = '🌺';
                                                      }
                                                    "></code-example>
                                                    <p>Consider an application with only an AppComponent and a ChildComponent. The most basic rendered view would look like nested HTML elements such as the following:</p>
                                                    <code-example code="
                                                    <app-root> <!-- AppComponent selector -->
                                                        <app-child> <!-- ChildComponent selector -->
                                                        </app-child>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>However, behind the scenes, Angular uses a logical view representation as follows when resolving injection requests:</p>
                                                    <code-example code="
                                                    <app-root> <!-- AppComponent selector -->
                                                        <#VIEW>
                                                            <app-child> <!-- ChildComponent selector -->
                                                                <#VIEW>
                                                                </#VIEW>
                                                            </app-child>
                                                        </#VIEW>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>The <#VIEW> here represents an instance of a template. Notice that each component has its own <#VIEW>.</p>
                                                    <p>Knowledge of this structure can inform how you provide and inject your services, and give you complete control of service visibility.</p>
                                                    <p>Now, consider that < app-root> injects the FlowerService:</p>
                                                    <code-example code="
                                                    export class AppComponent  {
                                                        constructor(public flower: FlowerService) {}
                                                      }
                                                    "></code-example>
                                                    <p>Add a binding to the < app-root> template to visualize the result:</p>
                                                    <code-example code="
                                                    <p>Emoji from FlowerService: [[flower.emoji]]</p>
                                                    "></code-example>
                                                    <p>The output in the view would be:</p>
                                                    <code-example code="
                                                    Emoji from FlowerService: 🌺
                                                    "></code-example>
                                                    <p>
                                                        In the logical tree, this would be represented as follows:
                                                    </p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(FlowerService) flower=>'🌺'>
                                                    <#VIEW>
                                                        <p>Emoji from FlowerService: [[flower.emoji]] (🌺)</p>
                                                        <app-child>
                                                        <#VIEW>
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>When < app-root> requests the FlowerService, it is the injector's job to resolve the FlowerService token. The resolution of the token happens in two phases:</p>
                                                    <ol>
                                                        <li>The injector determines the starting location in the logical tree and an ending location of the search. The injector begins with the starting location and looks for the token at each level in the logical tree. If the token is found it is returned.</li>
                                                        <li>If the token is not found, the injector looks for the closest parent @NgModule() to delegate the request to.</li>
                                                    </ol>

                                                    <p>In the example case, the constraints are:</p>
                                                    <ol>
                                                        <li>
                                                            <p>Start with <#VIEW> belonging to < app-root> and end with < app-root>.</p>
                                                            <ul>
                                                                <li>Normally the starting point for search is at the point of injection. However, in this case < app-root> @Components are special in that they also include their own viewProviders, which is why the search starts at <#VIEW> belonging to < app-root>. (This would not be the case for a directive matched at the same location).</li>
                                                                <li>The ending location happens to be the same as the component itself, because it is the topmost component in this application.</li>
                                                            </ul>
                                                        </li>
                                                        <li>The AppModule acts as the fallback injector when the injection token can't be found in the ElementInjectors.</li>
                                                    </ol>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_5_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Using the providers array
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_5_2>
                                                <ng-container #description_1_5_2>
                                                    <p>Now, in the ChildComponent class, add a provider for FlowerService to demonstrate more complex resolution rules in the upcoming sections:</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-child',
                                                        templateUrl: './child.component.html',
                                                        styleUrls: ['./child.component.css'],
                                                        // use the providers array to provide a service
                                                        providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }]
                                                      })
                                                      
                                                      export class ChildComponent {
                                                        // inject the service
                                                        constructor( public flower: FlowerService) { }
                                                      }
                                                    "></code-example>
                                                    <p>Now that the FlowerService is provided in the @Component() decorator, when the < app-child> requests the service, the injector has only to look as far as the < app-child>'s own ElementInjector. It won't have to continue the search any further through the injector tree.</p>
                                                    <p>The next step is to add a binding to the ChildComponent template.</p>
                                                    <code-example code="
                                                    <p>Emoji from FlowerService: [[flower.emoji]]</p>
                                                    "></code-example>
                                                    <p>To render the new values, add < app-child> to the bottom of the AppComponent template so the view also displays the sunflower:</p>
                                                    <code-example code="
                                                    Child Component
                                                    Emoji from FlowerService: 🌻
                                                    "></code-example>
                                                    <p>In the logical tree, this would be represented as follows:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                        @Inject(FlowerService) flower=>'🌺'>
                                                    <#VIEW>
                                                        <p>Emoji from FlowerService: [[flower.emoji]] (🌺)</p>
                                                        <app-child @Provide(FlowerService='🌻')
                                                                @Inject(FlowerService)=>'🌻'> <!-- search ends here -->
                                                        <#VIEW> <!-- search starts here -->
                                                            <h2>Parent Component</h2>
                                                            <p>Emoji from FlowerService: [[flower.emoji]] (🌻)</p>
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>

                                                    <p>When < app-child> requests the FlowerService, the injector begins its search at the <#VIEW> belonging to < app-child> (<#VIEW> is included because it is injected from @Component()) and ends with < app-child>. In this case, the FlowerService is resolved in the < app-child>'s providers array with sunflower 🌻. The injector doesn't have to look any further in the injector tree. It stops as soon as it finds the FlowerService and never sees the 🌺 (red hibiscus).</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_5_3>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Using the viewProviders array
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_5_3>
                                                <ng-container #description_1_5_3>
                                                    <p>Use the viewProviders array as another way to provide services in the @Component() decorator. Using viewProviders makes services visible in the <#VIEW>.</p>
                                                    <span class="note">
                                                        <p>The steps are the same as using the providers array, with the exception of using the viewProviders array instead.</p>
                                                        <p>For step-by-step instructions, continue with this section. If you can set it up on your own, skip ahead to Modifying service availability.</p>
                                                    </span>

                                                    <p>The example application features a second service, the AnimalService to demonstrate viewProviders.</p>
                                                    <p>First, create an AnimalService with an emoji property of 🐳 (whale):</p>
                                                    <code-example code="
                                                    import { Injectable } from '@angular/core';

                                                    @Injectable({
                                                      providedIn: 'root'
                                                    })
                                                    export class AnimalService {
                                                      emoji = '🐳';
                                                    }
                                                    "></code-example>
                                                    <p>Following the same pattern as with the FlowerService, inject the AnimalService in the AppComponent class:</p>
                                                    <code-example code="
                                                    export class AppComponent  {
                                                        constructor(public flower: FlowerService, public animal: AnimalService) {}
                                                      }
                                                    "></code-example>

                                                    <p class="note">Note: You can leave all the FlowerService related code in place as it will allow a comparison with the AnimalService.</p>
                                                    <p>Add a viewProviders array and inject the AnimalService in the < app-child> class, too, but give emoji a different value. Here, it has a value of 🐶 (puppy).</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-child',
                                                        templateUrl: './child.component.html',
                                                        styleUrls: ['./child.component.css'],
                                                        // provide services
                                                        providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }],
                                                        viewProviders: [{ provide: AnimalService, useValue: { emoji: '🐶' } }]
                                                      })
                                                      
                                                      export class ChildComponent {
                                                        // inject service
                                                        constructor( public flower: FlowerService, public animal: AnimalService) { }
                                                      }
                                                    "></code-example>
                                                    <p>Add bindings to the ChildComponent and the AppComponent templates. In the ChildComponent template, add the following binding:</p>
                                                    <code-example code="
                                                    <p>Emoji from AnimalService: [[animal.emoji]]</p>
                                                    "></code-example>
                                                    <p>Additionally, add the same to the AppComponent template:</p>
                                                    <code-example code="
                                                    <p>Emoji from AnimalService: [[animal.emoji]]</p>
                                                    "></code-example>

                                                    <p>Now you should see both values in the browser:</p>
                                                    <code-example code="
                                                    AppComponent
                                                    Emoji from AnimalService: 🐳
                                                    
                                                    Child Component
                                                    Emoji from AnimalService: 🐶
                                                    "></code-example>
                                                    <p>The logic tree for this example of viewProviders is as follows:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(AnimalService) animal=>'🐳'>
                                                    <#VIEW>
                                                        <app-child>
                                                        <#VIEW
                                                        @Provide(AnimalService='🐶')
                                                        @Inject(AnimalService=>'🐶')>
                                                        <!-- ^^using viewProviders means AnimalService is available in <#VIEW>-->
                                                        <p>Emoji from AnimalService: [[animal.emoji]] (🐶)</p>
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>

                                                    <p>Just as with the FlowerService example, the AnimalService is provided in the < app-child> @Component() decorator. This means that since the injector first looks in the ElementInjector of the component, it finds the AnimalService value of 🐶 (puppy). It doesn't need to continue searching the ElementInjector tree, nor does it need to search the ModuleInjector.</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_5_4>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    providers vs. viewProviders
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_5_4>
                                                <ng-container #description_1_5_4>
                                                    <p>To see the difference between using providers and viewProviders, add another component to the example and call it InspectorComponent. InspectorComponent will be a child of the ChildComponent. In inspector.component.ts, inject the FlowerService and AnimalService in the constructor:</p>
                                                    <code-example code="
                                                    export class InspectorComponent {
                                                        constructor(public flower: FlowerService, public animal: AnimalService) { }
                                                      }
                                                    "></code-example>
                                                    <p>You do not need a providers or viewProviders array. Next, in inspector.component.html, add the same markup from previous components:</p>
                                                    <code-example code="
                                                    <p>Emoji from FlowerService: [[flower.emoji]]</p>
                                                    <p>Emoji from AnimalService: [[animal.emoji]]</p>
                                                    "></code-example>
                                                    <p>Remember to add the InspectorComponent to the AppModule declarations array.</p>
                                                    <code-example code="
                                                    @NgModule({
                                                        imports:      [ BrowserModule, FormsModule ],
                                                        declarations: [ AppComponent, ChildComponent, InspectorComponent ],
                                                        bootstrap:    [ AppComponent ],
                                                        providers: []
                                                      })
                                                      export class AppModule { }
                                                    "></code-example>
                                                    <p>Next, make sure your child.component.html contains the following:</p>
                                                    <code-example code="
                                                    <p>Emoji from FlowerService: [[flower.emoji]]</p>
                                                    <p>Emoji from AnimalService: [[animal.emoji]]</p>
                                                    
                                                    <div class='container'>
                                                      <h3>Content projection</h3>
                                                        <ng-content></ng-content>
                                                    </div>
                                                    
                                                    <h3>Inside the view</h3>
                                                    <app-inspector></app-inspector>
                                                    "></code-example>
                                                    <p>The first two lines, with the bindings, are there from previous steps. The new parts are < ng-content> and < app-inspector>. < ng-content> allows you to project content, and < app-inspector> inside the ChildComponent template makes the InspectorComponent a child component of ChildComponent.</p>
                                                    <p>Next, add the following to app.component.html to take advantage of content projection.</p>
                                                    <code-example code="
                                                    <app-child><app-inspector></app-inspector></app-child>
                                                    "></code-example>
                                                    <p>The browser now renders the following, omitting the previous examples for brevity:</p>
                                                    <code-example code="
                                                    //...Omitting previous examples. The following applies to this section.

                                                    Content projection: This is coming from content. Doesn't get to see
                                                    puppy because the puppy is declared inside the view only.
                                                    
                                                    Emoji from FlowerService: 🌻
                                                    Emoji from AnimalService: 🐳
                                                    
                                                    Emoji from FlowerService: 🌻
                                                    Emoji from AnimalService: 🐶
                                                    "></code-example>
                                                    <p>These four bindings demonstrate the difference between providers and viewProviders. Since the 🐶 (puppy) is declared inside the <#VIEW>, it isn't visible to the projected content. Instead, the projected content sees the 🐳 (whale).</p>
                                                    <p>The next section though, where InspectorComponent is a child component of ChildComponent, InspectorComponent is inside the <#VIEW>, so when it asks for the AnimalService, it sees the 🐶 (puppy).</p>
                                                    <p>The AnimalService in the logical tree would look like this:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(AnimalService) animal=>'🐳'>
                                                        <#VIEW>
                                                            <app-child>
                                                            <#VIEW
                                                            @Provide(AnimalService='🐶')
                                                            @Inject(AnimalService=>'🐶')>
                                                            <!-- ^^using viewProviders means AnimalService is available in <#VIEW>-->
                                                            <p>Emoji from AnimalService: [[animal.emoji]] (🐶)</p>
                                                            <app-inspector>
                                                                <p>Emoji from AnimalService: [[animal.emoji]] (🐶)</p>
                                                            </app-inspector>
                                                            </#VIEW>
                                                            <app-inspector>
                                                                <#VIEW>
                                                                <p>Emoji from AnimalService: [[animal.emoji]] (🐳)</p>
                                                                </#VIEW>
                                                            </app-inspector>
                                                            </app-child>
                                                        </#VIEW>
                                                        </app-root>
                                                    "></code-example>
                                                    <p>The projected content of < app-inspector> sees the 🐳 (whale), not the 🐶 (puppy), because the 🐶 (puppy) is inside the  < app-child> <#VIEW>. The < app-inspector> can only see the 🐶 (puppy) if it is also within the <#VIEW>.</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_6>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        Modifying service visibility
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_6>
                                    <ng-container #description_1_6>
                                        <p>This section describes how to limit the scope of the beginning and ending ElementInjector using the visibility decorators @Host(), @Self(), and @SkipSelf().</p>
                                    </ng-container>

                                    <ng-container #content1_6_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Visibility of provided tokens
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_6_1>
                                                <ng-container #description_1_6_1>
                                                    <p>Visibility decorators influence where the search for the injection token begins and ends in the logic tree. To do this, place visibility decorators at the point of injection, that is, the constructor(), rather than at a point of declaration.</p>
                                                    <p>To alter where the injector starts looking for FlowerService, add @SkipSelf() to the < app-child> @Inject declaration for the FlowerService. This declaration is in the < app-child> constructor as shown in child.component.ts:</p>
                                                    <code-example code="
                                                    constructor(@SkipSelf() public flower : FlowerService) { }
                                                    "></code-example>
                                                    <p>With @SkipSelf(), the < app-child> injector doesn't look to itself for the FlowerService. Instead, the injector starts looking for the FlowerService at the < app-root>'s ElementInjector, where it finds nothing. Then, it goes back to the < app-child> ModuleInjector and finds the 🌺 (red hibiscus) value, which is available because the < app-child> ModuleInjector and the < app-root> ModuleInjector are flattened into one ModuleInjector. Thus, the UI renders the following:</p>
                                                    <code-example code="
                                                    Emoji from FlowerService: 🌺
                                                    "></code-example>
                                                    <p>In a logical tree, this same idea might look like this:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                            @Inject(FlowerService) flower=>'🌺'>
                                                    <#VIEW>
                                                        <app-child @Provide(FlowerService='🌻')>
                                                        <#VIEW @Inject(FlowerService, SkipSelf)=>'🌺'>
                                                        <!-- With SkipSelf, the injector looks to the next injector up the tree -->
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>Though < app-child> provides the 🌻 (sunflower), the application renders the 🌺 (red hibiscus) because @SkipSelf() causes the current injector to skip itself and look to its parent.</p>
                                                    <p>If you now add @Host() (in addition to the @SkipSelf()) to the @Inject of the FlowerService, the result will be null. This is because @Host() limits the upper bound of the search to the <#VIEW>. Here's the idea in the logical tree:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                                @Inject(FlowerService) flower=>'🌺'>
                                                        <#VIEW> <!-- end search here with null-->
                                                            <app-child @Provide(FlowerService='🌻')> <!-- start search here -->
                                                            <#VIEW @Inject(FlowerService, @SkipSelf, @Host, @Optional)=>null>
                                                            </#VIEW>
                                                            </app-parent>
                                                        </#VIEW>
                                                        </app-root>
                                                    "></code-example>
                                                    
                                                    <p>Here, the services and their values are the same, but @Host() stops the injector from looking any further than the <#VIEW> for FlowerService, so it doesn't find it and returns null.</p>

                                                    <p class="note">
                                                        Note: The example application uses @Optional() so the application does not throw an error, but the principles are the same.
                                                    </p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_6_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @SkipSelf() and viewProviders
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_6_2>
                                                <ng-container #description_1_6_2>
                                                    <p>The < app-child> currently provides the AnimalService in the viewProviders array with the value of 🐶 (puppy). Because the injector has only to look at the < app-child>'s ElementInjector for the AnimalService, it never sees the 🐳 (whale).</p>
                                                    <p>As in the FlowerService example, if you add @SkipSelf() to the constructor for the AnimalService, the injector won't look in the current < app-child>'s ElementInjector for the AnimalService.</p>
                                                    <code-example code="
                                                    export class ChildComponent {

                                                        // add @SkipSelf()
                                                          constructor(@SkipSelf() public animal : AnimalService) { }
                                                        
                                                        }
                                                    "></code-example>
                                                    <p>Instead, the injector will begin at the < app-root> ElementInjector. Remember that the < app-child> class provides the AnimalService in the viewProviders array with a value of 🐶 (puppy):</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-child',
                                                        ...
                                                        viewProviders:
                                                        [{ provide: AnimalService, useValue: { emoji: '🐶' } }]
                                                      }) 
                                                    "></code-example>
                                                    <p>The logical tree looks like this with @SkipSelf() in < app-child>:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(AnimalService=>'🐳')>
                                                    <#VIEW><!-- search begins here -->
                                                        <app-child>
                                                        <#VIEW
                                                        @Provide(AnimalService='🐶')
                                                        @Inject(AnimalService, SkipSelf=>'🐳')>
                                                        <!--Add @SkipSelf -->
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>

                                                    <p>With @SkipSelf() in the < app-child>, the injector begins its search for the AnimalService in the < app-root> ElementInjector and finds 🐳 (whale).</p>

                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_6_3>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    @Host() and viewProviders
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_6_3>
                                                <ng-container #description_1_6_3>
                                                    <p>If you add @Host() to the constructor for AnimalService, the result is 🐶 (puppy) because the injector finds the AnimalService in the < app-child> <#VIEW>. Here is the viewProviders array in the < app-child> class and @Host() in the constructor:</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-child',
                                                        ...
                                                        viewProviders:
                                                        [{ provide: AnimalService, useValue: { emoji: '🐶' } }]
                                                      
                                                      })
                                                      export class ChildComponent {
                                                        constructor(@Host() public animal : AnimalService) { }
                                                      }
                                                    "></code-example>
                                                    <p>@Host() causes the injector to look until it encounters the edge of the <#VIEW>.</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(AnimalService=>'🐳')>
                                                    <#VIEW>
                                                        <app-child>
                                                        <#VIEW
                                                        @Provide(AnimalService='🐶')
                                                        @Inject(AnimalService, @Host=>'🐶')> <!-- @Host stops search here -->
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>Add a viewProviders array with a third animal, 🦔 (hedgehog), to the app.component.ts @Component() metadata:</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-root',
                                                        templateUrl: './app.component.html',
                                                        styleUrls: [ './app.component.css' ],
                                                        viewProviders: [{ provide: AnimalService, useValue: { emoji: '🦔' } }]
                                                      })
                                                    "></code-example>

                                                    <p>Next, add @SkipSelf() along with @Host() to the constructor for the Animal Service in child.component.ts. Here are @Host() and @SkipSelf() in the < app-child> constructor :</p>
                                                    <code-example code="
                                                    export class ChildComponent {

                                                        constructor(
                                                        @Host() @SkipSelf() public animal : AnimalService) { }
                                                      
                                                      }
                                                    "></code-example>

                                                    <p>When @Host() and SkipSelf() were applied to the FlowerService, which is in the providers array, the result was null because @SkipSelf() starts its search in the < app-child> injector, but @Host() stops searching at <#VIEW>—where there is no FlowerService. In the logical tree, you can see that the FlowerService is visible in < app-child>, not its <#VIEW>.</p>
                                                    <p>However, the AnimalService, which is provided in the AppComponent viewProviders array, is visible.</p>
                                                    <p>The logical tree representation shows why this is:</p>
                                                    <code-example code="
                                                    <app-root @NgModule(AppModule)
                                                    @Inject(AnimalService=>'🐳')>
                                                    <#VIEW @Provide(AnimalService='🦔')
                                                            @Inject(AnimalService, @Optional)=>'🦔'>
                                                        <!-- ^^@SkipSelf() starts here,  @Host() stops here^^ -->
                                                        <app-child>
                                                        <#VIEW @Provide(AnimalService='🐶')
                                                                @Inject(AnimalService, @SkipSelf, @Host, @Optional)=>'🦔'>
                                                                <!-- Add @SkipSelf ^^-->
                                                        </#VIEW>
                                                        </app-child>
                                                    </#VIEW>
                                                    </app-root>
                                                    "></code-example>
                                                    <p>@SkipSelf(), causes the injector to start its search for the AnimalService at the < app-root>, not the < app-child>, where the request originates, and @Host() stops the search at the < app-root> <#VIEW>. Since AnimalService is provided by way of the viewProviders array, the injector finds 🦔 (hedgehog) in the <#VIEW>.</p>

                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                        <ng-container #content1_7>
                            <mat-accordion>
                              <mat-expansion-panel>
                                  <mat-expansion-panel-header>
                                      <mat-panel-title>
                                        ElementInjector use case examples
                                      </mat-panel-title>
                                  </mat-expansion-panel-header>
            
                                  <ng-container #content1Content_7>
                                    <ng-container #description_1_7>
                                        <p>The ability to configure one or more providers at different levels opens up useful possibilities.</p>
                                    </ng-container>

                                    <ng-container #content1_7_1>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Scenario: service isolation
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_7_1>
                                                <ng-container #description_1_7_1>
                                                    <p>Architectural reasons may lead you to restrict access to a service to the application domain where it belongs. For example, the guide sample includes a VillainsListComponent that displays a list of villains. It gets those villains from a VillainsService.</p>
                                                    <p>If you provided VillainsService in the root AppModule (where you registered the HeroesService), that would make the VillainsService visible everywhere in the application, including the Hero workflows. If you later modified the VillainsService, you could break something in a hero component somewhere.</p>
                                                    <p>Instead, you can provide the VillainsService in the providers metadata of the VillainsListComponent like this:</p>
                                                    <code-example code="
                                                    @Component({
                                                        selector: 'app-villains-list',
                                                        templateUrl: './villains-list.component.html',
                                                        providers: [ VillainsService ]
                                                      })
                                                    "></code-example>
                                                    <p>By providing VillainsService in the VillainsListComponent metadata and nowhere else, the service becomes available only in the VillainsListComponent and its sub-component tree.</p>
                                                    <p>VillainService is a singleton with respect to VillainsListComponent because that is where it is declared. As long as VillainsListComponent does not get destroyed it will be the same instance of VillainService but if there are multilple instances of VillainsListComponent, then each instance of VillainsListComponent will have its own instance of VillainService.</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_7_2>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Scenario: multiple edit sessions
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_7_2>
                                                <ng-container #description_1_7_2>
                                                    <p>Many applications allow users to work on several open tasks at the same time. For example, in a tax preparation application, the preparer could be working on several tax returns, switching from one to the other throughout the day.</p>
                                                    <p>This guide demonstrates that scenario with an example in the Tour of Heroes theme. Imagine an outer HeroListComponent that displays a list of super heroes.</p>
                                                    <p>To open a hero's tax return, the preparer clicks on a hero name, which opens a component for editing that return. Each selected hero tax return opens in its own component and multiple returns can be open at the same time.</p>
                                                    <p>Each tax return component has the following characteristics:</p>
                                                    <ul>
                                                        <li>Is its own tax return editing session.</li>
                                                        <li>Can change a tax return without affecting a return in another component.</li>
                                                        <li>Has the ability to save the changes to its tax return or cancel them.</li>
                                                    </ul>
                                                    <p>Suppose that the HeroTaxReturnComponent had logic to manage and restore changes. That would be a straightforward task for a hero tax return. In the real world, with a rich tax return data model, the change management would be tricky. You could delegate that management to a helper service, as this example does.</p>
                                                    <p>The HeroTaxReturnService caches a single HeroTaxReturn, tracks changes to that return, and can save or restore it. It also delegates to the application-wide singleton HeroService, which it gets by injection.</p>
                                                    <code-example code="
                                                    import { Injectable } from '@angular/core';
                                                    import { HeroTaxReturn } from './hero';
                                                    import { HeroesService } from './heroes.service';
                                                    
                                                    @Injectable()
                                                    export class HeroTaxReturnService {
                                                      private currentTaxReturn!: HeroTaxReturn;
                                                      private originalTaxReturn!: HeroTaxReturn;
                                                    
                                                      constructor(private heroService: HeroesService) { }
                                                    
                                                      set taxReturn(htr: HeroTaxReturn) {
                                                        this.originalTaxReturn = htr;
                                                        this.currentTaxReturn  = htr.clone();
                                                      }
                                                    
                                                      get taxReturn(): HeroTaxReturn {
                                                        return this.currentTaxReturn;
                                                      }
                                                    
                                                      restoreTaxReturn() {
                                                        this.taxReturn = this.originalTaxReturn;
                                                      }
                                                    
                                                      saveTaxReturn() {
                                                        this.taxReturn = this.currentTaxReturn;
                                                        this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();
                                                      }
                                                    }
                                                    "></code-example>
                                                    <p>Here is the HeroTaxReturnComponent that makes use of HeroTaxReturnService.</p>
                                                    <code-example code="
                                                    import { Component, EventEmitter, Input, Output } from '@angular/core';
                                                    import { HeroTaxReturn } from './hero';
                                                    import { HeroTaxReturnService } from './hero-tax-return.service';
                                                    
                                                    @Component({
                                                      selector: 'app-hero-tax-return',
                                                      templateUrl: './hero-tax-return.component.html',
                                                      styleUrls: [ './hero-tax-return.component.css' ],
                                                      providers: [ HeroTaxReturnService ]
                                                    })
                                                    export class HeroTaxReturnComponent {
                                                      message = '';
                                                    
                                                      @Output() close = new EventEmitter<void>();
                                                    
                                                      get taxReturn(): HeroTaxReturn {
                                                        return this.heroTaxReturnService.taxReturn;
                                                      }
                                                    
                                                      @Input()
                                                      set taxReturn(htr: HeroTaxReturn) {
                                                        this.heroTaxReturnService.taxReturn = htr;
                                                      }
                                                    
                                                      constructor(private heroTaxReturnService: HeroTaxReturnService) { }
                                                    
                                                      onCanceled()  {
                                                        this.flashMessage('Canceled');
                                                        this.heroTaxReturnService.restoreTaxReturn();
                                                      }
                                                    
                                                      onClose() { this.close.emit(); }
                                                    
                                                      onSaved() {
                                                        this.flashMessage('Saved');
                                                        this.heroTaxReturnService.saveTaxReturn();
                                                      }
                                                    
                                                      flashMessage(msg: string) {
                                                        this.message = msg;
                                                        setTimeout(() => this.message = '', 500);
                                                      }
                                                    }
                                                    "></code-example>
                                                    <p>The tax-return-to-edit arrives by way of the @Input() property, which is implemented with getters and setters. The setter initializes the component's own instance of the HeroTaxReturnService with the incoming return. The getter always returns what that service says is the current state of the hero. The component also asks the service to save and restore this tax return.</p>
                                                    <p>This won't work if the service is an application-wide singleton. Every component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.</p>
                                                    <p>To prevent this, configure the component-level injector of HeroTaxReturnComponent to provide the service, using the providers property in the component metadata.</p>
                                                    <code-example code="
                                                    providers: [ HeroTaxReturnService ]
                                                    "></code-example>
                                                    <p>The HeroTaxReturnComponent has its own provider of the HeroTaxReturnService. Recall that every component instance has its own injector. Providing the service at the component level ensures that every instance of the component gets its own, private instance of the service, and no tax return gets overwritten.</p>
                                                    <p class="note">
                                                        The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere in the documentation.
                                                    </p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                    <ng-container #content1_7_3>
                                        <mat-accordion>
                                          <mat-expansion-panel>
                                              <mat-expansion-panel-header>
                                                  <mat-panel-title>
                                                    Scenario: specialized providers
                                                  </mat-panel-title>
                                              </mat-expansion-panel-header>
                        
                                              <ng-container #content1Content_1_7_3>
                                                <ng-container #description_1_7_3>
                                                    <p>Another reason to re-provide a service at another level is to substitute a more specialized implementation of that service, deeper in the component tree.</p>
                                                    <p>Consider a Car component that depends on several services. Suppose you configured the root injector (marked as A) with generic providers for CarService, EngineService and TiresService.</p>
                                                    <p>You create a car component (A) that displays a car constructed from these three generic services.</p>
                                                    <p>Then you create a child component (B) that defines its own, specialized providers for CarService and EngineService that have special capabilities suitable for whatever is going on in component (B).</p>
                                                    <p>Component (B) is the parent of another component (C) that defines its own, even more specialized provider for CarService.</p>
                                                    <p>Behind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.</p>
                                                    <p>When you resolve an instance of Car at the deepest component (C), its injector produces an instance of Car resolved by injector (C) with an Engine resolved by injector (B) and Tires resolved by the root injector (A).</p>
                                                </ng-container>
                                            </ng-container>
                                          </mat-expansion-panel>
                                        </mat-accordion>
                                    </ng-container>

                                </ng-container>
                              </mat-expansion-panel>
                            </mat-accordion>
                        </ng-container>

                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

            <ng-container #content2>
                <mat-accordion>
                  <mat-expansion-panel>
                      <mat-expansion-panel-header>
                          <mat-panel-title>
                            Dependency injection in action
                          </mat-panel-title>
                      </mat-expansion-panel-header>

                      <ng-container #content2Content>
                        <ng-container #description_2></ng-container>
                    </ng-container>
                  </mat-expansion-panel>
                </mat-accordion>
            </ng-container>

        </ng-container>
    </mat-expansion-panel>
</ng-template>